#include <iostream>
#include <string>

#include "numerics/geometry3d/CoordinateTransformation3D.h"
#include "Grid3D.h"
#include "GenBlocksGridVisitor.h"
#include "numerics/geometry3d/GbSystem3D.h"
#include "numerics/geometry3d/GbCuboid3D.h"
#include "numerics/geometry3d/GbCylinder3D.h"
#include <numerics/geometry3d/GbSphere3D.h>
#include "basics/writer/WbWriterVtkXmlASCII.h"
#include "basics/writer/WbWriterVtkXmlBinary.h"
#include "RefineCrossAndInsideGbObjectBlockVisitor.h"
#include "RatioBlockVisitor.h"
#include "RatioSmoothBlockVisitor.h"
#include "OverlapBlockVisitor.h"
#include "RefineInterGbObjectsVisitor.h"
#include "RefineCrossAndInsideGbObjectBlockVisitor.h"
#include "SetKernelBlockVisitor.h"
#include "LBMKernelETD3Q27Cascaded.h"
#include "D3Q27MacroscopicQuantitiesPostprocessor.h"
#include "MPICommunicator.h"
#include "D3Q27ETBCProcessor.h"
#include "SimulationParameters.h"
#include "D3Q27SetUndefinedNodesBlockVisitor.h"
#include "SetInterpolationDirsBlockVisitor.h"
#include "D3Q27SetConnectorsBlockVisitor.h"
#include "NullCommunicator.h"
#include "D3Q27ETInitDistributionsBlockVisitor.h"
#include "CalculationManager.h"
#include "PQueuePartitioningGridVisitor.h"
#include "MetisPartitioningGridVisitor.h"
#include "D3Q27Interactor.h"
#include "D3Q27NoSlipBCAdapter.h"
#include "D3Q27VelocityBCAdapter.h"
#include "D3Q27DensityBCAdapter.h"
#include "D3Q27BoundaryConditionAdapter.h"
#include "StringUtil.hpp"
#include "D3Q27OffsetInterpolationProcessor.h"
#include "D3Q27CompactInterpolationProcessor.h"
#include "SyncBcBlockVisitor.h"
#include "numerics/geometry3d/creator/GbTriFaceMesh3DCreator.h"
#include "numerics/geometry3d/GbTriFaceMesh3D.h"
#include "D3Q27TriFaceMeshInteractor.h"
#include "MathUtil.hpp"
#include "SolidBlocksHelper.h"
#include "LBMKernelETD3Q27CascadedTI.h"
#include "TurbulenceIntensityPostprocessor.h"
#include "RestartPostprocessor.h"
#include "BlocksPostprocessor.h"
#include "NUPSCounterPostprocessor.h"

using namespace std;


void run(const char *cstr)
{
   try
   {
      string machine = QUOTEME(CAB_MACHINE);
      string BrueckeFilename;
      string ZckbndFilename;
      string pathname; 
      string pathGeo;
      int numOfThreads =1;
      bool logfile = false;
      double availMem = 0;

      CommunicatorPtr comm(new MPICommunicator());
      int myid = comm->getProcessID();
      
      if(machine == "BOMBADIL") 
      {
         pathname = "c:/temp/plate";
         pathGeo = "c:/Data/plate";
         numOfThreads = 1;
         logfile = false;
         availMem = 3.0e9;
      }
      else if(machine == "M01" || machine == "M02")      
      {
         pathname = "/work/koskuche/scratch/plate";
         pathGeo = "/home/koskuche/data/plate";
         numOfThreads = 8;
         availMem = 12.0e9;

         if(myid ==0)
         {
            stringstream logFilename;
            logFilename <<  pathname + "/logfile"+UbSystem::toString(UbSystem::getTimeStamp())+".txt";
            UbLog::output_policy::setStream(logFilename.str());
         }
      }
      else throw UbException(UB_EXARGS, "unknown CAB_MACHINE");

      BrueckeFilename = pathGeo + "/platte_raw.stl"; 
      ZckbndFilename= pathGeo + "/2zackenbaender0.stl";
      


      if(myid ==0 && logfile)
      {
         stringstream logFilename;
         logFilename <<  pathname + "/logfile.log";
         UbLog::output_policy::setStream(logFilename.str());
      }

      int baseLevel, refineLevel,nx[3],blocknx[3];
      double Re,velocity,rhoInit,vx1Init;//,vx2Init,vx3Init;

      //////////////////////////////////////////////////////////////////////////
      //physik
      //////////////////////////////////////////////////////////////////////////
      Re            = 11900;// 13286;//13286;//gemessen 18.98 m/s...*5.0 zum  testen ob was passiert
      velocity      = 0.01;  
      vx1Init       = 0.01;  
      rhoInit       = 1.0;
      SimulationParametersPtr param = SimulationParameters::getInstanz();
      param->setCollisionModelType(SimulationParameters::COMPRESSIBLE);

      ///////////////Knotenabmessungen:
      //int KnotenCubeCoarse=40;
      nx[0]      = 120;//60;//86;//43;//65;//50;  //länge
      nx[1]      = 1;//6;///1;//5;// //breite
      nx[2]      = 32;//18;//5;//15;//15; //höhe gebiet
      blocknx[0] = 15;
      blocknx[1] = 15;
      blocknx[2] = 15;

      baseLevel   = 0;
      refineLevel = 4;

      int inflowCubeLevel = 1;
      int bottomLevel     = 1;

      ///////////////Weltabmessungen:
      double kanalhoeheSI  = 60.0/100.0;//60.0/100.0;//cm, Kanalhöhe
      double kanalbreiteSI = 9.9/100.0;//1.65/100.0;//13.2/100.0;////40.0/100.0; //cm, Kanalbreite //13.2 zeilbreite
      double kanallaengeSI = kanalhoeheSI*30.0/18.0;//80.0/100.0;//cm, Kanallänge, ist nicht angegeben

      // double refinewidth1=kanalhoeheSI/10.0;

      double fineNodeDx   = (kanalhoeheSI) / (double)( blocknx[2]*nx[2]*(1<<refineLevel)+1 ); //+1--> gitter liegt jeweils 0.5dx innerhalb
      double coarseNodeDx = fineNodeDx * (double)(1<<refineLevel);//geowerte

      double blockLengthx1 = blocknx[0]*coarseNodeDx; //geowerte
      double blockLengthx2 = blockLengthx1;
      double blockLengthx3 = blockLengthx1;

      double originX1 = 0.0;//-50.0*propellerDurchmesser;  //geowerte
      double originX2 = 0.0;//-0.5*blockLengthx2*nx2;
      double originX3 = 0.0;// minX3 + 0.5*fineNodeDx;

      double geoLength[]   = {  nx[0]*blockLengthx1, nx[1]*blockLengthx2, nx[2]*blockLengthx3}; 

      //position vorderkante cube
      double originBridgeX1 = 20.0/100.0; //cm, geraten
      double originBridgeX2 = 0.0;//0.5*params.nx[1]*blockLengthx2-0.5*H-fineNodeDx;
      double originBridgeX3 = kanalhoeheSI*0.5;//H*0.0-fineNodeDx; //boden

      bool periodicx1 = false;
      bool periodicx2 = true;
      bool periodicx3 = true;

      //##########################################################################
      //## physical parameters
      //##########################################################################
      double smagorinskiConstant = 0.18;


      double rhoLB         = 1.0;
      double rhoReal       = 1.0;
      double nueReal  = 0.000015;//0.015;

      double hReal         = 0.0105;//<-m     1.05;//Plattendicke in cm(! cm nicht m !)
      double uReal         = Re*nueReal/hReal;

      //##Machzahl:
      //#Ma     = uReal/csReal
      double Ma      = 0.05;//0.0553;//Ma-Real!
      double csReal  = uReal/Ma;
      double hLB     = hReal/coarseNodeDx;

      LBMUnitConverter unitConverter(hReal, csReal, rhoReal, hLB);

      double uLB           = uReal   * unitConverter.getFactorVelocityWToLb();
      double nueLB         = nueReal * unitConverter.getFactorViscosityWToLb();

      velocity = uLB;
      double viscosity = nueLB;

      Grid3DPtr grid(new Grid3D());
      UbSchedulerPtr rSch(new UbScheduler(5000,5000,1000000));
      RestartPostprocessor rp(grid, rSch, comm, pathname+"/checkpoints", RestartPostprocessor::BINARY);

      //////////////////////////////////////////////////////////////////////////

      std::string opt;

      if(cstr!= NULL)
         opt = std::string(cstr);

      if(/*(cstr== NULL)*/cstr!= NULL)
      {
         opt = std::string(cstr);

         if(myid==0) UBLOG(logINFO,"Restart step: " << opt);

         grid = rp.restart(UbSystem::stringTo<int>(opt));

         //set connectors
         D3Q27InterpolationProcessorPtr iProcessor(new D3Q27OffsetInterpolationProcessor());
         D3Q27SetConnectorsBlockVisitor setConnsVisitor(comm, true, D3Q27System::ENDDIR, nueLB, iProcessor);
         grid->accept( setConnsVisitor );

         //domain decomposition
         PQueuePartitioningGridVisitor pqPartVisitor(numOfThreads);
         grid->accept(pqPartVisitor);
      }
      else
      {
      //bounding box
      double g_minX1 = originX1;
      double g_minX2 = originX2;
      double g_minX3 = originX3;

      double g_maxX1 = originX1 + geoLength[0];
      double g_maxX2 = originX2 + geoLength[1];
      double g_maxX3 = originX3 + geoLength[2];

      //set grid
      grid->setDeltaX(coarseNodeDx);
      grid->setBlockNX(blocknx[0], blocknx[1], blocknx[2]);
      grid->setPeriodicX1(periodicx1);
      grid->setPeriodicX2(periodicx2);
      grid->setPeriodicX3(periodicx3);

      
      GbObject3DPtr gridCube(new GbCuboid3D(g_minX1, g_minX2, g_minX3, g_maxX1, g_maxX2, g_maxX3));
      if(myid == 0) GbSystem3D::writeGeoObject(gridCube.get(), pathname+"/geo/gridCube", WbWriterVtkXmlASCII::getInstance());

      GenBlocksGridVisitor genBlocks;
      genBlocks.addGeoObject(gridCube);
      grid->accept(genBlocks);

      //////////////////////////////////////////////////////////////////////////
      //platte
      GbTriFaceMesh3DPtr mesh (GbTriFaceMesh3DCreator::getInstance()->readMeshFromSTLFile(BrueckeFilename,"Netz"));

      double x1minMesh = mesh->getX1Minimum(); double x1maxMesh = mesh->getX1Maximum();
      double x2minMesh = mesh->getX2Minimum(); double x2maxMesh = mesh->getX2Maximum();
      double x3minMesh = mesh->getX3Minimum(); double x3maxMesh = mesh->getX3Maximum();

      double drehpunktX=x1minMesh+(x1maxMesh-x1minMesh)*0.5;//triFaceMeshS->getX1Centroid();
      double drehpunktZ=x3minMesh+(x3maxMesh-x3minMesh)*0.5;//triFaceMeshS->getX3Centroid();
      double drehpunktY=x2minMesh+(x2maxMesh-x2minMesh)*0.5;// seedX2-0.5*nodeDelta;//+nx2*deltaX2+0.5*deltaX2;

      mesh->rotate(90.0,0.0,0.0);  //TriFacMesh-KO-System anders als LB-KO-System

      x1minMesh = mesh->getX1Minimum();  x1maxMesh = mesh->getX1Maximum();
      x2minMesh = mesh->getX2Minimum();  x2maxMesh = mesh->getX2Maximum();
      x3minMesh = mesh->getX3Minimum();  x3maxMesh = mesh->getX3Maximum();

      drehpunktX=x1minMesh+(x1maxMesh-x1minMesh)*0.5;//triFaceMeshS->getX1Centroid();
      drehpunktZ=x3minMesh+(x3maxMesh-x3minMesh)*0.5;//triFaceMeshS->getX3Centroid();
      drehpunktY=x2minMesh+(x2maxMesh-x2minMesh)*0.5;// seedX2-0.5*nodeDelta;//+nx2*deltaX2+0.5*deltaX2;

      double H3=1.05/100.0;//cm, Plattendicke
      double scaleB=H3/(x3maxMesh-x3minMesh);
      double scaleX2=(geoLength[2]+2.0*coarseNodeDx)/(x2minMesh-x2maxMesh);

      mesh->scale(scaleB,scaleB,scaleB);
      x1minMesh = mesh->getX1Minimum(); x1maxMesh = mesh->getX1Maximum();
      x2minMesh = mesh->getX2Minimum(); x2maxMesh = mesh->getX2Maximum();
      x3minMesh = mesh->getX3Minimum(); x3maxMesh = mesh->getX3Maximum();
      double offsetXBridge=originBridgeX1;//originBridgeX1;
      double offsetYBridge=originBridgeX2;//originBridgeX2;
      double offsetZBridge=originBridgeX3;//originBridgeX3;//-0.5*(x3minMesh-x3maxMesh);
      //mesh->translate(-x1minMesh+offsetXBridge, -x2minMesh-0.5*offsetYBridge-coarseNodeDx, -x3minMesh+offsetZBridge); 
      mesh->translate(-x1minMesh+offsetXBridge, -x2minMesh+offsetYBridge-coarseNodeDx, -x3minMesh+offsetZBridge-(x3maxMesh-x3minMesh)*0.5); 

      x1minMesh = mesh->getX1Minimum(); x1maxMesh = mesh->getX1Maximum();
      x2minMesh = mesh->getX2Minimum(); x2maxMesh = mesh->getX2Maximum();
      x3minMesh = mesh->getX3Minimum(); x3maxMesh = mesh->getX3Maximum();

      if(myid == 0) GbSystem3D::writeGeoObject( mesh.get(), pathname+"/geo/platte", WbWriterVtkXmlBinary::getInstance() );

      //////////////////////////////////////////////////////////////////////////
      // Zackenband
      //////////////////////////////////////////////////////////////////////////
      GbTriFaceMesh3DPtr meshBand (GbTriFaceMesh3DCreator::readMeshFromFile(ZckbndFilename, "NetzBand"));
      meshBand->deleteRedundantNodes();

      double x1minMeshB = meshBand->getX1Minimum(); double x1maxMeshB = meshBand->getX1Maximum();
      double x2minMeshB = meshBand->getX2Minimum(); double x2maxMeshB = meshBand->getX2Maximum();
      double x3minMeshB = meshBand->getX3Minimum(); double x3maxMeshB = meshBand->getX3Maximum();

      x1minMeshB = meshBand->getX1Minimum();  x1maxMeshB = meshBand->getX1Maximum();
      x2minMeshB = meshBand->getX2Minimum();  x2maxMeshB = meshBand->getX2Maximum();
      x3minMeshB = meshBand->getX3Minimum();  x3maxMeshB = meshBand->getX3Maximum();

      double H1B=1.5/100.0;//0.05;//cm, Banddicke..nachschauen!!!
      double scaleBand=H1B/(x1maxMeshB-x1minMeshB);//H3B/(x3maxMeshB-x3minMeshB);

      meshBand->scale(scaleBand,scaleBand,scaleBand);
      x1minMeshB = meshBand->getX1Minimum(); x1maxMeshB = meshBand->getX1Maximum();
      x2minMeshB = meshBand->getX2Minimum(); x2maxMeshB = meshBand->getX2Maximum();
      x3minMeshB = meshBand->getX3Minimum(); x3maxMeshB = meshBand->getX3Maximum();
      double dBandX=0.5/100.0;//1.29; //15mm-2.1mm Absand von Bandvorderkante
      double dBandY=0.0/100.0;
      double dBandZ=0.223/100.0;//0.344;//....
      double offsetXBridgeB=x1minMesh+dBandX;//originBridgeX1+dBandX;//originBridgeX1;
      double offsetYBridgeB=originBridgeX2+dBandY;//originBridgeX2;
      double offsetZBridgeB=originBridgeX3+dBandZ;//originBridgeX3;//-0.5*(x3minMesh-x3maxMesh);
      meshBand->translate(-x1minMeshB+offsetXBridgeB, -x2minMeshB+offsetYBridgeB-coarseNodeDx, -x3minMeshB+offsetZBridgeB);//-(x3maxMeshB-x3minMeshB)*0.5); 

      x1minMeshB = meshBand->getX1Minimum(); x1maxMeshB = meshBand->getX1Maximum();
      x2minMeshB = meshBand->getX2Minimum(); x2maxMeshB = meshBand->getX2Maximum();
      x3minMeshB = meshBand->getX3Minimum(); x3maxMeshB = meshBand->getX3Maximum();

      GbSystem3D::writeGeoObject( meshBand.get(), pathname+"/geo/Band", WbWriterVtkXmlASCII::getInstance() );

      /////////////////Band2
      GbTriFaceMesh3DPtr meshBand2(GbTriFaceMesh3DCreator::readMeshFromFile(ZckbndFilename, "NetzBand2"));
      meshBand->deleteRedundantNodes();

      double x1minMeshB2 = meshBand2->getX1Minimum(); double x1maxMeshB2 = meshBand2->getX1Maximum();
      double x2minMeshB2 = meshBand2->getX2Minimum(); double x2maxMeshB2 = meshBand2->getX2Maximum();
      double x3minMeshB2 = meshBand2->getX3Minimum(); double x3maxMeshB2 = meshBand2->getX3Maximum();

      x1minMeshB2 = meshBand2->getX1Minimum();  x1maxMeshB2 = meshBand2->getX1Maximum();
      x2minMeshB2 = meshBand2->getX2Minimum();  x2maxMeshB2 = meshBand2->getX2Maximum();
      x3minMeshB2 = meshBand2->getX3Minimum();  x3maxMeshB2 = meshBand2->getX3Maximum();

      double H1B2=1.5/100.0;//0.05;//cm, Banddicke..nachschauen!!!
      double scaleBand2=H1B2/(x1maxMeshB2-x1minMeshB2);//H3B/(x3maxMeshB-x3minMeshB);

      meshBand2->scale(scaleBand2,scaleBand2,scaleBand2);
      x1minMeshB2 = meshBand2->getX1Minimum(); x1maxMeshB2 = meshBand2->getX1Maximum();
      x2minMeshB2 = meshBand2->getX2Minimum(); x2maxMeshB2 = meshBand2->getX2Maximum();
      x3minMeshB2 = meshBand2->getX3Minimum(); x3maxMeshB2 = meshBand2->getX3Maximum();
      double dBandX2=0.5/100.0;//1.29;
      double dBandY2=0.5/100.0;
      double dBandZ2=0.223/100.0;//0.344;//...
      double offsetXBridgeB2=x1minMesh+dBandX2;//originBridgeX1;
      double offsetYBridgeB2=originBridgeX2+dBandY2;//originBridgeX2;
      double offsetZBridgeB2=originBridgeX3+dBandZ2;//originBridgeX3;//-0.5*(x3minMesh-x3maxMesh);
      meshBand2->translate(-x1minMeshB2+offsetXBridgeB2, -x2minMeshB2+offsetYBridgeB2-coarseNodeDx, -x3minMeshB2+offsetZBridgeB2);//-(x3maxMeshB2-x3minMeshB2)*0.5); 

      x1minMeshB2 = meshBand2->getX1Minimum(); x1maxMeshB2 = meshBand2->getX1Maximum();
      x2minMeshB2 = meshBand2->getX2Minimum(); x2maxMeshB2 = meshBand2->getX2Maximum();
      x3minMeshB2 = meshBand2->getX3Minimum(); x3maxMeshB2 = meshBand2->getX3Maximum();

      if(myid == 0) GbSystem3D::writeGeoObject( meshBand2.get(), pathname+"/geo/Band2", WbWriterVtkXmlASCII::getInstance() );
      //////////////////////////////////////////////////////////////////////////
      if(myid == 0) 
      {
         UBLOG(logINFO, "*****************************************");
         UBLOG(logINFO, "* Parameters                            *");
         UBLOG(logINFO, "* Re            ="<<Re);
         UBLOG(logINFO, "* Ma            ="<<Ma);
         UBLOG(logINFO, "* uReal         ="<<uReal);
         UBLOG(logINFO, "* nueReal       ="<<nueReal);
         UBLOG(logINFO, "* nue           ="<<nueLB);
         UBLOG(logINFO, "* velocity      ="<<uLB);
         UBLOG(logINFO, "* LX1 (world/LB)="<<kanallaengeSI<<"/"<<kanallaengeSI/coarseNodeDx);
         UBLOG(logINFO, "* LX2 (world/LB)="<<kanalbreiteSI<<"/"<<kanalbreiteSI/coarseNodeDx);
         UBLOG(logINFO, "* LX3 (world/LB)="<<kanalhoeheSI<<"/"<<kanalhoeheSI/coarseNodeDx);
         //UBLOG(logINFO, "* dxInflow-Cube ="<<velBCCuboid->getX1Maximum()-mesh->getX1Minimum());
         UBLOG(logINFO, "* cdx           ="<<coarseNodeDx);
         UBLOG(logINFO, "* fdx           ="<<fineNodeDx);
         //UBLOG(logINFO, "* inflowProfile ="<<inflowProfile.GetExpr());
         UBLOG(logINFO, "* dx_base       ="<<coarseNodeDx<<" == "<<coarseNodeDx);
         UBLOG(logINFO, "* dx_refine     ="<<fineNodeDx<<" == "<<fineNodeDx );
         //UBLOG(logINFO, "* raiseVelSteps ="<<raiseVelSteps);
         UBLOG(logINFO, "* nx1/2/3       ="<<nx[0]<<"/"<<nx[1]<<"/"<<nx[2]);
         UBLOG(logINFO, "* blocknx1/2/3  ="<<blocknx[0]<<"/"<<blocknx[1]<<"/"<<blocknx[2]);
         UBLOG(logINFO, "* x2Periodic    ="<<periodicx2);
         UBLOG(logINFO, "* x3Periodic    ="<<periodicx3);
         UBLOG(logINFO, "*****************************************");
         UBLOGML(logINFO, "UnitConverter:"<<unitConverter.toString());
         UBLOG(logINFO, "*****************************************");     
      }
      if(myid == 0) UBLOG(logINFO,"Refinement - start");	
      double geoOverlap = 3.0*coarseNodeDx;
      //////////////////////////////////////////////////////////////////////////
      // refine
      //////////////////////////////////////////////////////////////////////////
      ///////////platte ausmessen:
      x1minMesh = mesh->getX1Minimum(); x1maxMesh = mesh->getX1Maximum();
      x2minMesh = mesh->getX2Minimum(); x2maxMesh = mesh->getX2Maximum();
      x3minMesh = mesh->getX3Minimum(); x3maxMesh = mesh->getX3Maximum();
      double deltaX3Platte=(x3maxMesh-x3minMesh);


      //GbCuboid3DPtr refine1PlatteCube(new GbCuboid3D(  originX1-geoOverlap   , originX2-geoOverlap  , x3minMesh-H3
      //   , x1maxMesh+H3*5.0, originX2+geoOverlap+geoLength[1], x3maxMesh+H3));
      //RefineCrossAndInsideGbObjectBlockVisitor refineAdapterP1(refine1PlatteCube, baseLevel, refineLevel-6);
      //grid->accept(refineAdapterP1);

      // GbCuboid3DPtr refine2PlatteCube(new GbCuboid3D(  originX1-geoOverlap   , originX2-geoOverlap  , x3minMesh-H3*0.5
        // , x1maxMesh+H3*5.0, originX2+geoOverlap+geoLength[1], x3maxMesh+H3));
      // RefineCrossAndInsideGbObjectBlockVisitor refineAdapterP2(refine2PlatteCube, baseLevel, refineLevel-5);
      // grid->accept(refineAdapterP2);

      GbCuboid3DPtr refine3PlatteCube(new GbCuboid3D(  originX1-geoOverlap  , originX2-geoOverlap  , x3minMesh-H3*0.5
         , x1maxMesh+H3*5.0, originX2+geoOverlap+geoLength[1], x3maxMesh+H3*0.5));
      RefineCrossAndInsideGbObjectBlockVisitor refineAdapterP3(refine3PlatteCube, baseLevel, refineLevel-4);
      grid->accept(refineAdapterP3);

      GbCuboid3DPtr refine4PlatteCube(new GbCuboid3D(   originX1-geoOverlap  , originX2-geoOverlap  , x3minMesh+deltaX3Platte*0.0
         ,  x1maxMesh+H3*5.0, originX2+geoOverlap+geoLength[1], x3maxMesh+H3*0.25));
      if(myid == 0) GbSystem3D::writeGeoObject(refine4PlatteCube.get(), pathname+"/geo/refine4PlatteCube", WbWriterVtkXmlASCII::getInstance());
      RefineCrossAndInsideGbObjectBlockVisitor refineAdapterP4(refine4PlatteCube, baseLevel, refineLevel-3);
      grid->accept(refineAdapterP4);

      GbCuboid3DPtr refine5PlatteCube(new GbCuboid3D(   originX1-geoOverlap , originX2-geoOverlap  ,x3minMesh+deltaX3Platte*0.1/* x3minMesh+deltaX3Platte*0.8*/
         ,  x1maxMesh+H3*5.0, originX2+geoOverlap+geoLength[1], x3maxMesh+H3*0.00375));
      if(myid == 0) GbSystem3D::writeGeoObject(refine5PlatteCube.get(), pathname+"/geo/refine5PlatteCube", WbWriterVtkXmlASCII::getInstance());
      RefineCrossAndInsideGbObjectBlockVisitor refineAdapterP5(refine5PlatteCube, baseLevel, refineLevel-2);
      grid->accept(refineAdapterP5);

      GbCuboid3DPtr refine6PlatteCube(new GbCuboid3D(   originX1-geoOverlap   , originX2-geoOverlap  , x3minMesh-deltaX3Platte*0.1/*x3minMesh+deltaX3Platte*0.9*/
         ,  x1maxMesh+H3*5.0, originX2+geoOverlap+geoLength[1], x3maxMesh+deltaX3Platte*0.9));
      if(myid == 0) GbSystem3D::writeGeoObject(refine6PlatteCube.get(), pathname+"/geo/refine6PlatteCube", WbWriterVtkXmlASCII::getInstance());
      RefineCrossAndInsideGbObjectBlockVisitor refineAdapterP6(refine6PlatteCube, baseLevel, refineLevel-1);
      grid->accept(refineAdapterP6);

      //GbCuboid3DPtr refine7PlatteCube(new GbCuboid3D(originX1-geoOverlap   , originX2-geoOverlap  , x3minMesh-deltaX3Platte*0.3, 
      //                                               meshBand->getX1Maximum()+meshBand->getLengthX1()*3.0, originX2+geoOverlap+geoLength[1], x3maxMesh));
      //if(myid == 0) GbSystem3D::writeGeoObject(refine7PlatteCube.get(), pathname+"/geo/refine7PlatteCube", WbWriterVtkXmlASCII::getInstance());
      //RefineCrossAndInsideGbObjectBlockVisitor refineAdapterP7(refine7PlatteCube, baseLevel, refineLevel-1);
      //grid->accept(refineAdapterP7);

      RatioBlockVisitor ratioVisitor(refineLevel);
      grid->accept(ratioVisitor);
      RatioSmoothBlockVisitor ratioSmoothVisitor(refineLevel);
      grid->accept(ratioSmoothVisitor);
      OverlapBlockVisitor overlapVisitor(refineLevel);
      grid->accept(overlapVisitor);
      std::vector<int> dirs;
      D3Q27System::getLBMDirections(dirs);
      SetInterpolationDirsBlockVisitor interDirsVisitor(dirs);
      grid->accept(interDirsVisitor);

      if(myid == 0) UBLOG(logINFO,"Refinement - end");

      if(myid == 0) UBLOG(logINFO,"Write blocks - start");
      BlocksPostprocessorPtr ppblocks(new BlocksPostprocessor(grid, UbSchedulerPtr(new UbScheduler(1)), pathname + "/grid/blocks", WbWriterVtkXmlBinary::getInstance(), comm));
      if(myid == 0) ppblocks->update(0);
      //ppblocks.reset();
      if(myid == 0) UBLOG(logINFO,"Write blocks - end");
      
      MetisPartitioningGridVisitor metisVisitor(numOfThreads, D3Q27System::B, comm, false);
      grid->accept( metisVisitor );

      if(myid == 0) UBLOG(logINFO,"deleteSolidBlocks - start");
      SolidBlocksHelper sd(grid, comm);

      //iteractors
      int bbOption1 = 0; //0=simple Bounce Back, 1=quadr. BB
      D3Q27BoundaryConditionAdapterPtr bcObst(new D3Q27NoSlipBCAdapter(bbOption1));

      D3Q27TriFaceMeshInteractorPtr triBridgeInteractor( new D3Q27TriFaceMeshInteractor(mesh, grid, bcObst,Interactor3D::SOLID));
      sd.addInteractor(triBridgeInteractor);

      D3Q27TriFaceMeshInteractorPtr triBandInteractor( new D3Q27TriFaceMeshInteractor( meshBand, grid, bcObst,Interactor3D::SOLID) );

      D3Q27TriFaceMeshInteractorPtr triBand2Interactor( new D3Q27TriFaceMeshInteractor( meshBand2, grid, bcObst,Interactor3D::SOLID) );

      sd.deleteSolidBlocks();
      if(myid == 0) UBLOG(logINFO,"deleteSolidBlocks - end");	      
      
      if(myid == 0) UBLOG(logINFO,"Write blocks - start");
      grid->accept( metisVisitor );
      //BlocksPostprocessorPtr ppblocks(new BlocksPostprocessor(grid, UbSchedulerPtr(new UbScheduler(1)), pathname + "/grid/blocks", WbWriterVtkXmlBinary::getInstance(), comm));
      if(myid == 0) ppblocks->update(0);
      ppblocks.reset();
      if(myid == 0) UBLOG(logINFO,"Write blocks - end");

      unsigned long nob = grid->getNumberOfBlocks();
      unsigned long nod = nob * blocknx[0]*blocknx[1]*blocknx[2];
      
      double needMemAll  = double(nod*(27*sizeof(double) + sizeof(int))*2);
      double needMem  = needMemAll / double(comm->getNumberOfProcesses());

      if(myid == 0)
      {
         UBLOG(logINFO,"Number of blocks = " << nob);
         UBLOG(logINFO,"Number of nodes  = " << nod);
         UBLOG(logINFO,"Necessary memory  = " << needMemAll  << " bytes");
         UBLOG(logINFO,"Necessary memory per process = " << needMem  << " bytes");
         UBLOG(logINFO,"Available memory per process = " << availMem << " bytes");
      }

      LBMKernel3DPtr kernel(new LBMKernelETD3Q27Cascaded(blocknx[0], blocknx[1], blocknx[2]));
      BCProcessorPtr bcProc(new D3Q27ETBCProcessor());
      kernel->setBCProcessor(bcProc);

      SetKernelBlockVisitor kernelVisitor(kernel, nueLB, availMem, needMem);
      grid->accept(kernelVisitor);

      if (refineLevel > 0)
      {
         D3Q27SetUndefinedNodesBlockVisitor undefNodesVisitor;
         grid->accept(undefNodesVisitor);
      }

      //discretization
      grid->addAndInitInteractor(triBridgeInteractor);
      grid->addAndInitInteractor(triBandInteractor);
      grid->addAndInitInteractor(triBand2Interactor);

      //outflow
      GbCuboid3DPtr densCuboid(new GbCuboid3D(originX1+geoLength[0]-coarseNodeDx, originX2-geoOverlap, originX3-geoOverlap, 
                                              originX1+geoLength[0]+geoOverlap, originX2+geoLength[1]+geoOverlap, originX3+geoLength[2]+geoOverlap ));
      if(myid == 0) GbSystem3D::writeGeoObject(densCuboid.get(), pathname+"/geo/densCuboid", WbWriterVtkXmlASCII::getInstance());
      D3Q27BoundaryConditionAdapterPtr denBCAdapter(new D3Q27DensityBCAdapter(rhoInit));
      D3Q27InteractorPtr densInteractor( new D3Q27Interactor(densCuboid,grid,denBCAdapter,Interactor3D::SOLID) );
      grid->addAndInitInteractor( densInteractor ); 

      //inflow
      double uLB2=uLB*0.96*1.02;//*0.5;
      double raiseVelSteps = 0;
      vector<D3Q27BCFunction> velcX1BCs,dummy;

      mu::Parser inflowProfile;
      inflowProfile.SetExpr("uLB"); 

      inflowProfile.DefineConst("uLB",uLB2);
      velcX1BCs.push_back(D3Q27BCFunction(inflowProfile,raiseVelSteps,D3Q27BCFunction::INFCONST));

      GbCuboid3DPtr velBCCuboid(new GbCuboid3D(originX1-geoOverlap, originX2-geoOverlap, originX3-geoOverlap, 
                                               originX1+coarseNodeDx, originX2+geoLength[1]+geoOverlap, originX3+geoLength[2]+geoOverlap));
      if(myid == 0) GbSystem3D::writeGeoObject(velBCCuboid.get(), pathname+"/geo/velBCCuboid", WbWriterVtkXmlASCII::getInstance());

      D3Q27InteractorPtr velBCInteractor(new D3Q27Interactor(velBCCuboid,grid,Interactor3D::SOLID)); 
      D3Q27BoundaryConditionAdapterPtr velBCAdapter(new D3Q27VelocityBCAdapter (velcX1BCs,dummy,dummy));
      velBCInteractor->addBCAdapter(velBCAdapter);
      grid->addAndInitInteractor( velBCInteractor ); 

      //set connectors
      D3Q27InterpolationProcessorPtr iProcessor(new D3Q27OffsetInterpolationProcessor());
      D3Q27SetConnectorsBlockVisitor setConnsVisitor(comm, true, D3Q27System::ENDDIR, nueLB, iProcessor);
      grid->accept( setConnsVisitor );

      //domain decomposition
      PQueuePartitioningGridVisitor pqPartVisitor(numOfThreads);
      grid->accept(pqPartVisitor);

      //initialization of decompositions
      D3Q27ETInitDistributionsBlockVisitor initVisitor(1.0);
      initVisitor.setVx1(inflowProfile);
      grid->accept(initVisitor);

      //Postrozess
      LBMUnitConverterPtr conv = LBMUnitConverterPtr(new LBMUnitConverter());
      
      UbSchedulerPtr geoSch(new UbScheduler(1));
      D3Q27MacroscopicQuantitiesPostprocessorPtr ppgeo(
           new D3Q27MacroscopicQuantitiesPostprocessor(grid, geoSch, pathname + "/grid/nodes", WbWriterVtkXmlBinary::getInstance(), 
                                                       conv, comm, true));
      grid->doPostProcess(0);
      ppgeo.reset();
      geoSch.reset();

      if(myid == 0) UBLOG(logINFO,"Preprozess - end");    
      
      if(myid == 0) 
      {
         UBLOG(logINFO, "* dxInflow-Cube ="<<velBCCuboid->getX1Maximum()-mesh->getX1Minimum());
         UBLOG(logINFO, "* inflowProfile ="<<inflowProfile.GetExpr());
         UBLOG(logINFO, "* raiseVelSteps ="<<raiseVelSteps);
      }
}
      
      LBMUnitConverterPtr conv = LBMUnitConverterPtr(new LBMUnitConverter());
      double outTime = 1000;
      UbSchedulerPtr visSch(new UbScheduler(outTime));
      visSch->addSchedule(1000,1000,10000);
      visSch->addSchedule(10000,10000,100000);
      visSch->addSchedule(100000,100000,1000000);
      D3Q27MacroscopicQuantitiesPostprocessor pp(grid, visSch, pathname + "/steps/step", WbWriterVtkXmlBinary::getInstance(), conv, comm);

      UbSchedulerPtr nupsSch(new UbScheduler(10, 30, 100));
      NUPSCounterPostprocessor npr(grid, nupsSch, pathname + "/results/nups.txt", comm);

      double endTime = 1000001;
      CalculationManagerPtr calculation(new CalculationManager(grid, numOfThreads, endTime, visSch));
      if(myid == 0) UBLOG(logINFO,"Simulation-start");
      calculation->calculate();
      if(myid == 0) UBLOG(logINFO,"Simulation-end");
   }
   catch(std::exception& e)
   {
      cerr << e.what() << endl << flush;
   }
   catch(std::string& s)
   {
      cerr << s << endl;
   }
   catch(...)
   {
      cerr << "unknown exception" << endl;
   }

}
int main(int argc, char* argv[])
{

   run(argv[1]);

   return 0;
}

