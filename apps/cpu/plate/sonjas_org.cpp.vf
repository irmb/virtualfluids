

..damit wir gleich damit anfangen k�nnen. So sieht das Setup aus.
Sonja


SpD3Q19Plattenanstroemung.hpp

#include <topology/amr3d/blockadaptation/AMR3DCrossAndInsideGbObject3DAdapter.h>
//AMR3DCrossAndInsideGbObject3DAdapter
#include <topology/amr3d/lbmd3q19/utils/D3Q19MetisTools.h>
#include <topology/amr3d/lbmd3q19/gridadaptation/D3Q19GridInformationGridAdapter.h>
#include <topology/amr3d/lbmd3q19/gridadaptation/D3Q19SetConnectorsGridAdapter.h>
#include <topology/amr3d/lbmd3q19/gridadaptation/D3Q19InitDistributionsGridAdapter.h>
#include <topology/amr3d/gridadaptation/AMR3DGridLevelPartitionMetisAdapter.h>
#include <topology/amr3d/gridadaptation/AMR3DGridPartitionOneDirectionAdapter.h>
#include <topology/amr3d/lbmd3q19/bcadapter/D3Q19DensityLodiBCAdapter.h>
#include <topology/amr3d/lbmd3q19/singlephase/gridadaptation/SpD3Q19SpongeLayerAdapter.h>
#include <topology/amr3d/lbmd3q19/gridadaptation/D3Q19InitDistributionsGridAdapter.h>

#include <numerics/geometry3d/GbTriFaceMesh3D.h>
#include <numerics/geometry3d/creator/GbTriFaceMesh3DCreator.h>
#include <topology/amr3d/lbmd3q19/interactor/D3Q19AMRTriFaceMeshInteractor.h>
#include <topology/amr3d/lbmd3q19/services/adapter/D3Q19ClientGridWriteInteractorNodeFiles.h>
#include <topology/amr3d/lbmd3q19/gridadaptation/D3Q19ChangeSlipToNoSlipGridAdapter.h> 

using namespace std;

void SpD3Q19MasterTestcases::start( RcfClient<IRcfIpService>& ipService, 
                                   RcfClient<IRcfD3Q19TopologyService>& topoService, 
                                   RcfClient<IRcfD3Q19AMRInteractorService>& interactorService, 
                                   RcfClient<IRcfD3Q19CalculationManager>& calculationManager,
                                   std::vector< RcfClient<IRcfD3Q19CalcService> >& calcServices,
                                   std::string inputfile )
{
   using namespace std;
   UBLOG(logERROR,"Testcase GBBridge_Sonja "); 

   string outpath = UbStaticPathMap::getPath(UbStaticPathMap::GLOBAL);

   SpD3Q19TestCaseParameters params;
   bool useLODI;
   bool initWithLogProfile;
   //////////////////////////////////////////////////////////////////////////
   // Params
   //////////////////////////////////////////////////////////////////////////
   // if( inputfile.empty() )
   // {
   params.calcSteps          = 300000;
   params.threadedClientCall = true;

   //params.distributedDumpScheduler = UbScheduler(5000, 0);
   params.distributedDumpScheduler.addSchedule(UbSchedule(100,0,100));
   params.distributedDumpScheduler.addSchedule(UbSchedule(100,100,6000));
   params.distributedDumpScheduler.addSchedule(UbSchedule(1000,6000,10000));
   params.distributedDumpScheduler.addSchedule(UbSchedule(5000,10000,Ub::inf));

   //params.schedulers.calcForces    = UbScheduler(10,0);
   //params.schedulers.writeForces   = UbScheduler(500,500);
   params.schedulers.resetAverage  = UbScheduler(50000,50000);
   params.schedulers.serialization = UbScheduler(20000,20000);

   //Schnickschnack(  so lassen, da geht es im Wesentlichen um Kommunikationsdetails)
   params.connsTransAttr.setRemoteProtocol(D3Q19ConnectorTransmitterAttributes::MPI_PROTOCOL);
   params.connsTransAttr.setOptionDirectConnectors(true);
   params.connsTransAttr.setOptionTwoVectorsForLocalVectors(false);
   params.connsTransAttr.setOptionConsForNotActiveBlocks(true);
   params.connsTransAttr.setOptionRemoteBlockedSend(false);
   params.connsTransAttr.setOptionRemoteBlockedReceive(true);
   params.connsTransAttr.setOptionRemotePool(true);
   params.connsTransAttr.setOptionStlVecForSameLevelCons(false);
   params.connsTransAttr.setOptionStlVecForScaleCons(false);

#ifndef CAB_MPI
   if(params.connsTransAttr.getRemoteProtocol() == D3Q19ConnectorTransmitterAttributes::MPI_PROTOCOL) 
      throw UbException(UB_EXARGS,"MPI Transmitter not available for this compilation without /DCAB_MPI");
#endif

   string machine = QUOTEME(CAB_MACHINE);
   string BrueckeFilename;
   string ZckbndFilename;
   if(machine == "ARAGORN")     {  BrueckeFilename = "f:/data/bruecke/platte_raw.stl"; ZckbndFilename="f:/data/bruecke/zweiPlatten0.stl";}
   else if(machine == "LUDWIG") {  BrueckeFilename = "/hpc3lustre/home/sonuphof/Stl-Zeichnungen/platte_raw.stl"; ZckbndFilename="/hpc3lustre/home/sonuphof/Stl-Zeichnungen/2zackenbaender0.stl";}
   else if(machine == "PIPPIN") {  BrueckeFilename = "C:/platteD291009/sonja2/svn_uphoff/Daten/SFB880/platte-cad/platte_raw.stl"; ZckbndFilename="C:/platteD291009/sonja2/svn_uphoff/Daten/SFB880/platte-cad/2zackenbaender0.stl";}
   else throw UbException(UB_EXARGS, "unknown CAB_MACHINE");


   //////////////////////////////////////////////////////////////////////////
   //physik
   //////////////////////////////////////////////////////////////////////////
   params.Re            = 11900;// 13286;//13286;//gemessen 18.98 m/s...*5.0 zum  testen ob was passiert
   params.velocity      = 0.01;  
   params.vx1Init       = 0.01;  
   params.rhoInit       = 0.0;
   initWithLogProfile   = true;
   useLODI              = false;

   params.collModel = D3Q19System::INCOMPGLBEJTLESMODEL;
   ///////////////Knotenabmessungen:
   //int KnotenCubeCoarse=40;
   params.nx[0]      = 120;//60;//86;//43;//65;//50;  //l�nge
   params.nx[1]      = 6;///1;//5;// //breite
   params.nx[2]      = 32;//18;//5;//15;//15; //h�he gebiet
   params.blocknx[0] = 10;
   params.blocknx[1] = 10;
   params.blocknx[2] = 10;

   params.baseLevel   = 0;
   params.refineLevel = 3;

   int inflowCubeLevel = 1;
   int bottomLevel     = 1;

   ///////////////Weltabmessungen:
   double kanalhoeheSI  = 60.0/100.0;//60.0/100.0;//cm, Kanalh�he
   double kanalbreiteSI = 9.9/100.0;//1.65/100.0;//13.2/100.0;////40.0/100.0; //cm, Kanalbreite //13.2 zeilbreite
   double kanallaengeSI = kanalhoeheSI*30.0/18.0;//80.0/100.0;//cm, Kanall�nge, ist nicht angegeben

   // double refinewidth1=kanalhoeheSI/10.0;

   double fineNodeDx   = (kanalhoeheSI) / (double)( params.blocknx[2]*params.nx[2]*(1<<params.refineLevel)+1 ); //+1--> gitter liegt jeweils 0.5dx innerhalb
   double coarseNodeDx = fineNodeDx * (double)(1<<params.refineLevel);//geowerte

   double blockLengthx1 = params.blocknx[0]*coarseNodeDx; //geowerte
   double blockLengthx2 = blockLengthx1;
   double blockLengthx3 = blockLengthx1;

   double originX1 = 0.0;//-50.0*propellerDurchmesser;  //geowerte
   double originX2 = 0.0;//-0.5*blockLengthx2*nx2;
   double originX3 = 0.0;// minX3 + 0.5*fineNodeDx;

   double geoLength[]   = {  params.nx[0]*blockLengthx1, params.nx[1]*blockLengthx2, params.nx[2]*blockLengthx3}; 

   //position vorderkante cube
   double originBridgeX1 = 20.0/100.0; //cm, geraten
   double originBridgeX2 = 0.0;//0.5*params.nx[1]*blockLengthx2-0.5*H-fineNodeDx;
   double originBridgeX3 = kanalhoeheSI*0.5;//H*0.0-fineNodeDx; //boden

   bool periodicx1 = false;
   bool periodicx2 = true;
   bool periodicx3 = false;

#ifndef CAB_MPI
   if(params.connsTransAttr.getRemoteProtocol() == D3Q19ConnectorTransmitterAttributes::MPI_PROTOCOL) 
      throw UbException("LbD3Q19MasterTestcases::startChannelFlow - MPI Transmitter not available for this compilation without /DCAB_MPI");
#endif

   //weitere parameter
   double raiseVelSteps                  = 0;
   double startViscosity                 = 1.0/3.0;
   int    decreaseViscositySteps         = 6000;
   int    decreaseViscosityStepForHalVis = (int)(1.0/8.0*decreaseViscositySteps);

   if( D3Q19System::isCompModel(params.collModel) ) params.rhoInit = 1.0;
   //////////////////////////////////////////////////////////////////////////
   //grid initialization
   //////////////////////////////////////////////////////////////////////////
   UBLOG2(logINFO, std::cout, "grid initialization...");

   CoordinateTransformation3D* trafo = new CoordinateTransformation3D(originX1,originX2, originX3, blockLengthx1, blockLengthx2, blockLengthx3);
   vector< boost::shared_ptr<AMR3DGridAdaptationCriterion> > adapter;
   UBLOG(logINFO,"set periodic")
   adapter.push_back( boost::shared_ptr<AMR3DGridAdaptationCriterion>(new AMR3DSetPeriodicAdapter(periodicx1, params.nx[0], periodicx2, params.nx[1], periodicx3, params.nx[2])) );
      UBLOG(logINFO,"construct block grid")
   topoService.constructBlockGrid("MyGrid", UbTupleInt6(params.nx[0],params.nx[1],params.nx[2],params.blocknx[0],params.blocknx[1],params.blocknx[2]), params.baseLevel, UbPointerWrapper<CoordinateTransformation3D>(trafo),adapter );

   UBLOG2(logINFO, std::cout, "grid initialization... done");

   //##########################################################################

   double geoOverlap = 3.0*coarseNodeDx;

   //////////////////////////////////////////////////////////////////////////////

   GbTriFaceMesh3D* mesh = GbTriFaceMesh3DCreator::readMeshFromFile(BrueckeFilename, "Netz");
    mesh->deleteRedundantNodes();

     double x1minMesh = mesh->getX1Minimum(); double x1maxMesh = mesh->getX1Maximum();
   double x2minMesh = mesh->getX2Minimum(); double x2maxMesh = mesh->getX2Maximum();
   double x3minMesh = mesh->getX3Minimum(); double x3maxMesh = mesh->getX3Maximum();

   double drehpunktX=x1minMesh+(x1maxMesh-x1minMesh)*0.5;//triFaceMeshS->getX1Centroid();
   double drehpunktZ=x3minMesh+(x3maxMesh-x3minMesh)*0.5;//triFaceMeshS->getX3Centroid();
   double drehpunktY=x2minMesh+(x2maxMesh-x2minMesh)*0.5;// seedX2-0.5*nodeDelta;//+nx2*deltaX2+0.5*deltaX2;

     mesh->rotateAroundPoint(drehpunktZ,drehpunktX,drehpunktY,90.0,0.0,0.0);  //TriFacMesh-KO-System anders als LB-KO-System

   x1minMesh = mesh->getX1Minimum();  x1maxMesh = mesh->getX1Maximum();
   x2minMesh = mesh->getX2Minimum();  x2maxMesh = mesh->getX2Maximum();
   x3minMesh = mesh->getX3Minimum();  x3maxMesh = mesh->getX3Maximum();

   drehpunktX=x1minMesh+(x1maxMesh-x1minMesh)*0.5;//triFaceMeshS->getX1Centroid();
   drehpunktZ=x3minMesh+(x3maxMesh-x3minMesh)*0.5;//triFaceMeshS->getX3Centroid();
   drehpunktY=x2minMesh+(x2maxMesh-x2minMesh)*0.5;// seedX2-0.5*nodeDelta;//+nx2*deltaX2+0.5*deltaX2;

   double H3=1.05/100.0;//cm, Plattendicke
   double scaleB=H3/(x3maxMesh-x3minMesh);
   double scaleX2=(geoLength[2]+2.0*coarseNodeDx)/(x2minMesh-x2maxMesh);

   mesh->scale(scaleB,scaleB,scaleB);
   x1minMesh = mesh->getX1Minimum(); x1maxMesh = mesh->getX1Maximum();
   x2minMesh = mesh->getX2Minimum(); x2maxMesh = mesh->getX2Maximum();
   x3minMesh = mesh->getX3Minimum(); x3maxMesh = mesh->getX3Maximum();
   double offsetXBridge=originBridgeX1;//originBridgeX1;
   double offsetYBridge=originBridgeX2;//originBridgeX2;
   double offsetZBridge=originBridgeX3;//originBridgeX3;//-0.5*(x3minMesh-x3maxMesh);
   //mesh->translate(-x1minMesh+offsetXBridge, -x2minMesh-0.5*offsetYBridge-coarseNodeDx, -x3minMesh+offsetZBridge); 
   mesh->translate(-x1minMesh+offsetXBridge, -x2minMesh+offsetYBridge-coarseNodeDx, -x3minMesh+offsetZBridge-(x3maxMesh-x3minMesh)*0.5); 

   x1minMesh = mesh->getX1Minimum(); x1maxMesh = mesh->getX1Maximum();
   x2minMesh = mesh->getX2Minimum(); x2maxMesh = mesh->getX2Maximum();
   x3minMesh = mesh->getX3Minimum(); x3maxMesh = mesh->getX3Maximum();

   GbSystem3D::writeGeoObject( mesh, UbStaticPathMap::getPath(UbStaticPathMap::GLOBAL)+"/platte", WbWriterVtkXmlBinary::getInstance() );

   //GbTriFaceMesh3D* Bruecke = GbTriFaceMesh3DCreator::getInstance()->readMeshFromFile(BrueckeFilename         ,"Bruecke");
   // Bruecke->setPointInObjectTest(GbTriFaceMesh3D::RAYCROSSING);//, HALFSPACE, MEGARAY, SEGURA, GELLER)
   //D3Q19AMRTriFaceMeshInteractor* triInteractor = new D3Q19AMRTriFaceMeshInteractor(mesh, grid,new D3Q19NoSlipBCAdapter, AMR3DInteractor::SOLID);
   boost::shared_ptr<D3Q19AMRTriFaceMeshInteractor> triBridgeInteractor( new D3Q19AMRTriFaceMeshInteractor( mesh,new D3Q19NoSlipBCAdapter,AMR3DInteractor::SOLID,"bridge") );

   //grid->addAndInitInteractor(triInteractor);
   interactorService.addInteractor(triBridgeInteractor);

     //////////////////////////////////////////////////////////////////////////////

 //////////////////////////////////////////////////////////////////////////
   // Zackenband
   //////////////////////////////////////////////////////////////////////////
     GbTriFaceMesh3D* meshBand = GbTriFaceMesh3DCreator::readMeshFromFile(ZckbndFilename, "NetzBand");
    meshBand->deleteRedundantNodes();

   double x1minMeshB = meshBand->getX1Minimum(); double x1maxMeshB = meshBand->getX1Maximum();
   double x2minMeshB = meshBand->getX2Minimum(); double x2maxMeshB = meshBand->getX2Maximum();
   double x3minMeshB = meshBand->getX3Minimum(); double x3maxMeshB = meshBand->getX3Maximum();

   //double drehpunktXB=x1minMeshB+(x1maxMeshB-x1minMeshB)*0.5;//triFaceMeshS->getX1Centroid();
   //double drehpunktZB=x3minMeshB+(x3maxMeshB-x3minMeshB)*0.5;//triFaceMeshS->getX3Centroid();
   //double drehpunktYB=x2minMeshB+(x2maxMeshB-x2minMeshB)*0.5;// seedX2-0.5*nodeDelta;//+nx2*deltaX2+0.5*deltaX2;

    // meshBand->rotateAroundPoint(drehpunktZB,drehpunktXB,drehpunktYB,90.0,0.0,0.0);  //TriFacMesh-KO-System anders als LB-KO-System

   x1minMeshB = meshBand->getX1Minimum();  x1maxMeshB = meshBand->getX1Maximum();
   x2minMeshB = meshBand->getX2Minimum();  x2maxMeshB = meshBand->getX2Maximum();
   x3minMeshB = meshBand->getX3Minimum();  x3maxMeshB = meshBand->getX3Maximum();

   //drehpunktXB=x1minMeshB+(x1maxMeshB-x1minMeshB)*0.5;//triFaceMeshS->getX1Centroid();
   //drehpunktZB=x3minMeshB+(x3maxMeshB-x3minMeshB)*0.5;//triFaceMeshS->getX3Centroid();
   //drehpunktYB=x2minMeshB+(x2maxMeshB-x2minMeshB)*0.5;// seedX2-0.5*nodeDelta;//+nx2*deltaX2+0.5*deltaX2;

   double H1B=1.5/100.0;//0.05;//cm, Banddicke..nachschauen!!!
   double scaleBand=H1B/(x1maxMeshB-x1minMeshB);//H3B/(x3maxMeshB-x3minMeshB);
 //  double scaleX2B=(geoLength[2]+2.0*coarseNodeDx)/(x2minMeshB-x2maxMeshB);

   meshBand->scale(scaleBand,scaleBand,scaleBand);
   x1minMeshB = meshBand->getX1Minimum(); x1maxMeshB = meshBand->getX1Maximum();
   x2minMeshB = meshBand->getX2Minimum(); x2maxMeshB = meshBand->getX2Maximum();
   x3minMeshB = meshBand->getX3Minimum(); x3maxMeshB = meshBand->getX3Maximum();
   double dBandX=0.5/100.0;//1.29; //15mm-2.1mm Absand von Bandvorderkante
   double dBandY=0.0/100.0;
   double dBandZ=0.223/100.0;//0.344;//....
   double offsetXBridgeB=x1minMesh+dBandX;//originBridgeX1+dBandX;//originBridgeX1;
   double offsetYBridgeB=originBridgeX2+dBandY;//originBridgeX2;
   double offsetZBridgeB=originBridgeX3+dBandZ;//originBridgeX3;//-0.5*(x3minMesh-x3maxMesh);
   //mesh->translate(-x1minMesh+offsetXBridge, -x2minMesh-0.5*offsetYBridge-coarseNodeDx, -x3minMesh+offsetZBridge); 
   meshBand->translate(-x1minMeshB+offsetXBridgeB, -x2minMeshB+offsetYBridgeB-coarseNodeDx, -x3minMeshB+offsetZBridgeB);//-(x3maxMeshB-x3minMeshB)*0.5); 

   x1minMeshB = meshBand->getX1Minimum(); x1maxMeshB = meshBand->getX1Maximum();
   x2minMeshB = meshBand->getX2Minimum(); x2maxMeshB = meshBand->getX2Maximum();
   x3minMeshB = meshBand->getX3Minimum(); x3maxMeshB = meshBand->getX3Maximum();

   GbSystem3D::writeGeoObject( meshBand, UbStaticPathMap::getPath(UbStaticPathMap::GLOBAL)+"/Band", WbWriterVtkXmlBinary::getInstance() );

   //GbTriFaceMesh3D* Bruecke = GbTriFaceMesh3DCreator::getInstance()->readMeshFromFile(BrueckeFilename         ,"Bruecke");
   // Bruecke->setPointInObjectTest(GbTriFaceMesh3D::RAYCROSSING);//, HALFSPACE, MEGARAY, SEGURA, GELLER)
   //D3Q19AMRTriFaceMeshInteractor* triInteractor = new D3Q19AMRTriFaceMeshInteractor(mesh, grid,new D3Q19NoSlipBCAdapter, AMR3DInteractor::SOLID);
   boost::shared_ptr<D3Q19AMRTriFaceMeshInteractor> triBandInteractor( new D3Q19AMRTriFaceMeshInteractor( meshBand,new D3Q19NoSlipBCAdapter,AMR3DInteractor::SOLID,"band") );
   interactorService.addInteractor(triBandInteractor);
    /////////////////Band2


      GbTriFaceMesh3D* meshBand2 = GbTriFaceMesh3DCreator::readMeshFromFile(ZckbndFilename, "NetzBand2");
    meshBand->deleteRedundantNodes();

   double x1minMeshB2 = meshBand2->getX1Minimum(); double x1maxMeshB2 = meshBand2->getX1Maximum();
   double x2minMeshB2 = meshBand2->getX2Minimum(); double x2maxMeshB2 = meshBand2->getX2Maximum();
   double x3minMeshB2 = meshBand2->getX3Minimum(); double x3maxMeshB2 = meshBand2->getX3Maximum();

   //double drehpunktXB2=x1minMeshB2+(x1maxMeshB2-x1minMeshB2)*0.5;//triFaceMeshS->getX1Centroid();
   //double drehpunktZB2=x3minMeshB2+(x3maxMeshB2-x3minMeshB2)*0.5;//triFaceMeshS->getX3Centroid();
   //double drehpunktYB2=x2minMeshB2+(x2maxMeshB2-x2minMeshB2)*0.5;// seedX2-0.5*nodeDelta;//+nx2*deltaX2+0.5*deltaX2;

//     meshBand2->rotateAroundPoint(drehpunktZB2,drehpunktXB2,drehpunktYB2,90.0,0.0,0.0);  //TriFacMesh-KO-System anders als LB-KO-System

   x1minMeshB2 = meshBand2->getX1Minimum();  x1maxMeshB2 = meshBand2->getX1Maximum();
   x2minMeshB2 = meshBand2->getX2Minimum();  x2maxMeshB2 = meshBand2->getX2Maximum();
   x3minMeshB2 = meshBand2->getX3Minimum();  x3maxMeshB2 = meshBand2->getX3Maximum();

   //drehpunktXB2=x1minMeshB2+(x1maxMeshB2-x1minMeshB2)*0.5;//triFaceMeshS->getX1Centroid();
   //drehpunktZB2=x3minMeshB2+(x3maxMeshB2-x3minMeshB2)*0.5;//triFaceMeshS->getX3Centroid();
   //drehpunktYB2=x2minMeshB2+(x2maxMeshB2-x2minMeshB2)*0.5;// seedX2-0.5*nodeDelta;//+nx2*deltaX2+0.5*deltaX2;

   double H1B2=1.5/100.0;//0.05;//cm, Banddicke..nachschauen!!!
   double scaleBand2=H1B2/(x1maxMeshB2-x1minMeshB2);//H3B/(x3maxMeshB-x3minMeshB);

   meshBand2->scale(scaleBand2,scaleBand2,scaleBand2);
   x1minMeshB2 = meshBand2->getX1Minimum(); x1maxMeshB2 = meshBand2->getX1Maximum();
   x2minMeshB2 = meshBand2->getX2Minimum(); x2maxMeshB2 = meshBand2->getX2Maximum();
   x3minMeshB2 = meshBand2->getX3Minimum(); x3maxMeshB2 = meshBand2->getX3Maximum();
   double dBandX2=0.5/100.0;//1.29;
   double dBandY2=0.5/100.0;
   double dBandZ2=0.223/100.0;//0.344;//...
   double offsetXBridgeB2=x1minMesh+dBandX2;//originBridgeX1;
   double offsetYBridgeB2=originBridgeX2+dBandY2;//originBridgeX2;
   double offsetZBridgeB2=originBridgeX3+dBandZ2;//originBridgeX3;//-0.5*(x3minMesh-x3maxMesh);
   //mesh->translate(-x1minMesh+offsetXBridge, -x2minMesh-0.5*offsetYBridge-coarseNodeDx, -x3minMesh+offsetZBridge); 
   meshBand2->translate(-x1minMeshB2+offsetXBridgeB2, -x2minMeshB2+offsetYBridgeB2-coarseNodeDx, -x3minMeshB2+offsetZBridgeB2);//-(x3maxMeshB2-x3minMeshB2)*0.5); 

   x1minMeshB2 = meshBand2->getX1Minimum(); x1maxMeshB2 = meshBand2->getX1Maximum();
   x2minMeshB2 = meshBand2->getX2Minimum(); x2maxMeshB2 = meshBand2->getX2Maximum();
   x3minMeshB2 = meshBand2->getX3Minimum(); x3maxMeshB2 = meshBand2->getX3Maximum();

   GbSystem3D::writeGeoObject( meshBand2, UbStaticPathMap::getPath(UbStaticPathMap::GLOBAL)+"/Band2", WbWriterVtkXmlBinary::getInstance() );

   //GbTriFaceMesh3D* Bruecke = GbTriFaceMesh3DCreator::getInstance()->readMeshFromFile(BrueckeFilename         ,"Bruecke");
   // Bruecke->setPointInObjectTest(GbTriFaceMesh3D::RAYCROSSING);//, HALFSPACE, MEGARAY, SEGURA, GELLER)
   //D3Q19AMRTriFaceMeshInteractor* triInteractor = new D3Q19AMRTriFaceMeshInteractor(mesh, grid,new D3Q19NoSlipBCAdapter, AMR3DInteractor::SOLID);
   boost::shared_ptr<D3Q19AMRTriFaceMeshInteractor> triBand2Interactor( new D3Q19AMRTriFaceMeshInteractor( meshBand2,new D3Q19NoSlipBCAdapter,AMR3DInteractor::SOLID,"band2") );
    interactorService.addInteractor(triBand2Interactor);
   
   //////////////////////////////////////////////////////////////////////////
   // refine
   //////////////////////////////////////////////////////////////////////////
                        


   



   ///////////platte ausmessen:
   x1minMesh = mesh->getX1Minimum(); x1maxMesh = mesh->getX1Maximum();
   x2minMesh = mesh->getX2Minimum(); x2maxMesh = mesh->getX2Maximum();
   x3minMesh = mesh->getX3Minimum(); x3maxMesh = mesh->getX3Maximum();
  double deltaX3Platte=(x3maxMesh-x3minMesh);


      GbCuboid3D* refine1PlatteCube = new GbCuboid3D(  originX1-geoOverlap   , originX2-geoOverlap  , x3minMesh-H3
      , x1maxMesh+H3*5.0, originX2+geoOverlap+geoLength[1], x3maxMesh+H3);
   boost::shared_ptr<AMR3DBlockAdaptationCriterion> refineAdapterP1(new AMR3DCrossAndInsideGbObject3DAdapter(refine1PlatteCube,0,params.refineLevel-6));
   topoService.adaptGridByBlockCriterion(refineAdapterP1);

        GbCuboid3D* refine2PlatteCube = new GbCuboid3D(  originX1-geoOverlap   , originX2-geoOverlap  , x3minMesh-H3*0.5
      , x1maxMesh+H3*5.0, originX2+geoOverlap+geoLength[1], x3maxMesh+H3);
   boost::shared_ptr<AMR3DBlockAdaptationCriterion> refineAdapterP2(new AMR3DCrossAndInsideGbObject3DAdapter(refine2PlatteCube,0,params.refineLevel-5));
   topoService.adaptGridByBlockCriterion(refineAdapterP2);

        GbCuboid3D* refine3PlatteCube = new GbCuboid3D(  originX1-geoOverlap  , originX2-geoOverlap  , x3minMesh-H3*0.5
      , x1maxMesh+H3*5.0, originX2+geoOverlap+geoLength[1], x3maxMesh+H3*0.5);
   boost::shared_ptr<AMR3DBlockAdaptationCriterion> refineAdapterP3(new AMR3DCrossAndInsideGbObject3DAdapter(refine3PlatteCube,0,params.refineLevel-4));   //dieser hier hat eine ecke 
   topoService.adaptGridByBlockCriterion(refineAdapterP3);

        GbCuboid3D* refine4PlatteCube = new GbCuboid3D(   originX1-geoOverlap  , originX2-geoOverlap  , x3minMesh+deltaX3Platte*0.6
      ,  x1maxMesh+H3*5.0, originX2+geoOverlap+geoLength[1], x3maxMesh+H3*0.25);
   boost::shared_ptr<AMR3DBlockAdaptationCriterion> refineAdapterP4(new AMR3DCrossAndInsideGbObject3DAdapter(refine4PlatteCube,0,params.refineLevel-3));   //weil der hier zu hoch ist
   topoService.adaptGridByBlockCriterion(refineAdapterP4);

           GbCuboid3D* refine5PlatteCube = new GbCuboid3D(   originX1-geoOverlap , originX2-geoOverlap  , x3minMesh+deltaX3Platte*0.8
      ,  x1maxMesh+H3*5.0, originX2+geoOverlap+geoLength[1], x3maxMesh+H3*0.00375);
   boost::shared_ptr<AMR3DBlockAdaptationCriterion> refineAdapterP5(new AMR3DCrossAndInsideGbObject3DAdapter(refine5PlatteCube,0,params.refineLevel-2));
   topoService.adaptGridByBlockCriterion(refineAdapterP5);

  //            GbCuboid3D* refine6PlatteCube = new GbCuboid3D(   x1minMeshB2+( x1maxMeshB2- x1minMeshB2)*0.8   , originX2-geoOverlap  , x3minMesh+deltaX3Platte*0.9
  //    ,  x1maxMesh+H3*0.075, originX2+geoOverlap+geoLength[1], x3maxMesh+2.0*fineNodeDx);
  // boost::shared_ptr<AMR3DBlockAdaptationCriterion> refineAdapterP6(new AMR3DCrossAndInsideGbObject3DAdapter(refine6PlatteCube,0,params.refineLevel-1));
  // topoService.adaptGridByBlockCriterion(refineAdapterP6);

           GbCuboid3D* refine6PlatteCube = new GbCuboid3D(   originX1-geoOverlap   , originX2-geoOverlap  , x3minMesh+deltaX3Platte*0.9
      ,  x1maxMesh+H3*5.0, originX2+geoOverlap+geoLength[1], x3maxMesh+deltaX3Platte*0.9);
   boost::shared_ptr<AMR3DBlockAdaptationCriterion> refineAdapterP6(new AMR3DCrossAndInsideGbObject3DAdapter(refine6PlatteCube,0,params.refineLevel-1));
   topoService.adaptGridByBlockCriterion(refineAdapterP6);

     UBLOG2(logINFO, std::cout, "Refinement..done");
   //blockverh�ltnis von 2:1 herstellen:
   UBLOG(logINFO,"ratio")
      boost::shared_ptr<AMR3DBlockAdaptationCriterion> ratioAdapter(new AMR3DBlockRatioAdapter(params.refineLevel));
   topoService.adaptGridByBlockCriterion(ratioAdapter);



   //////////////////////////////////////////////////////////////////////////
   //walls                                                                                                   
   ////////////////////////////////////////////////////////////////////////// 
   int noSlipSecOpt = 1; //0=2nd order BB 1=simple BB
   int slipSecOpt   = 1; //0=2nd order BB 1=simple BB

   ////x1x2-walls:                                                                                             
   GbCuboid3D* wallsX1X2min = new GbCuboid3D(  originX1-geoOverlap   , originX2-geoOverlap  , originX3-geoOverlap
      , originX1+geoLength[0]+geoOverlap, originX2+geoOverlap+geoLength[1], originX3-0.5*fineNodeDx);
   boost::shared_ptr<D3Q19AMRInteractor> wallsX1X2minInteractor( new D3Q19AMRInteractor( wallsX1X2min,new D3Q19SlipBCAdapter(slipSecOpt),AMR3DInteractor::SOLID,"wallsX1X2min") );
   if(!params.periodic[2]) interactorService.addInteractor( wallsX1X2minInteractor );

   GbCuboid3D* wallsX1X2max = new GbCuboid3D(  originX1-geoOverlap , originX2-geoOverlap , originX3+geoLength[2]+0.5*fineNodeDx            
      , originX1+geoLength[0]+geoOverlap, originX2+geoOverlap+geoLength[1], originX3+geoLength[2]+geoOverlap); 
   boost::shared_ptr<D3Q19AMRInteractor> wallsX1X2maxInteractor( new D3Q19AMRInteractor( wallsX1X2max,new D3Q19SlipBCAdapter(slipSecOpt),AMR3DInteractor::SOLID,"wallsX1X2max") ) ;  
   if(!params.periodic[2]) interactorService.addInteractor( wallsX1X2maxInteractor );


  

   //##########################################################################
   //## physical parameters
   //##########################################################################
   double smagorinskiConstant = 0.18;


   double rhoLB         = 1.0;
   double rhoReal       = 1.0;
   double nueReal  = 0.000015;//0.015;

   double hReal         = 0.0105;//<-m     1.05;//Plattendicke in cm(! cm nicht m !)
   double uReal         = params.Re*nueReal/hReal;

   //##Machzahl:
   //#Ma     = uReal/csReal
   double Ma      = 0.05;//0.0553;//Ma-Real!
   double csReal  = uReal/Ma;
   double hLB     = hReal/coarseNodeDx;

   D3Q19UnitConverter unitConverter(hReal, csReal, rhoReal, hLB );

   double uLB           = uReal   * unitConverter.getFactorVelocityWToLb();
   double nueLB         = nueReal * unitConverter.getFactorViscosityWToLb();

   params.velocity = uLB;
   double viscosity = nueLB;

   //////////////////////////////////////////////////////////////////////////
   // BCs
   //////////////////////////////////////////////////////////////////////////
   //////////////////////////////////////////////////////////////////////////
   // inflow
   //////////////////////////////////////////////////////////////////////////


   double uLB2=uLB*0.96*1.02;//*0.5;

   vector<D3Q19BCFunction> velcX1BCs,dummy;

   if(raiseVelSteps>0)
   {
      mu::Parser inflowProfile1;
         inflowProfile1.SetExpr("uLB"); 
    
          inflowProfile1.DefineConst("uLB",uLB2);
   }
   mu::Parser inflowProfile;
   inflowProfile.SetExpr("uLB"); 

   inflowProfile.DefineConst("uLB",uLB2);
   //inflowProfile.DefineConst("xlbnachxworld",xlbnachxworld);
   velcX1BCs.push_back(D3Q19BCFunction(inflowProfile,raiseVelSteps,D3Q19BCFunction::INFCONST));


   GbCuboid3D* velBCCuboid = NULL;
   velBCCuboid = new GbCuboid3D(  originX1-geoOverlap, originX2-geoOverlap, originX3-geoOverlap
      , originX1-fineNodeDx, originX2+geoLength[1]+geoOverlap, originX3+geoLength[2]+geoOverlap);

   boost::shared_ptr< D3Q19AMRInteractor> velBCInteractor(new D3Q19AMRInteractor(velBCCuboid,AMR3DInteractor::SOLID,"velBC")); 
   velBCInteractor->addBCAdapter(new D3Q19VelocityBCAdapter(velcX1BCs,dummy,dummy) );
   interactorService.addInteractor( velBCInteractor ); 



   //////////////////////////////////////////////////////////////////////////
   // outflow
   //////////////////////////////////////////////////////////////////////////
   GbCuboid3D* densCuboid = NULL;
   densCuboid = new GbCuboid3D(  originX1+geoLength[0]+fineNodeDx, originX2-geoOverlap             , originX3-geoOverlap
      , originX1+geoLength[0]+geoOverlap, originX2+geoLength[1]+geoOverlap, originX3+geoLength[2]+geoOverlap );

   if(useLODI)
   {
      float LX1 = (float)((densCuboid->getX1Minimum()-velBCCuboid->getX1Maximum())/coarseNodeDx);
      float LX2 = -1.0f;
      float LX3 = -1.0f;

      D3Q19DensityLodiBCAdapter* lodiBCadapter = new D3Q19DensityLodiBCAdapter(3,LX1,LX2,LX3,params.rhoInit,params.vx1Init,params.vx2Init,params.vx3Init,params.rhoInit);
      boost::shared_ptr< D3Q19AMRInteractor> densInteractor(new D3Q19AMRInteractor(densCuboid,lodiBCadapter,AMR3DInteractor::SOLID,"lodiDensBC"));
      interactorService.addInteractor( densInteractor ); 
   }
   else
   {
      boost::shared_ptr< D3Q19AMRInteractor> densInteractor( new D3Q19AMRInteractor(densCuboid,new D3Q19DensityBCAdapter(params.rhoInit),AMR3DInteractor::SOLID,"densBC") );
      interactorService.addInteractor( densInteractor ); 
   }

   UBLOG(logINFO, "*****************************************");
   UBLOG(logINFO, "* Parameters                            *");
   UBLOG(logINFO, "* Re            ="<<params.Re);
   UBLOG(logINFO, "* Ma            ="<<Ma);
   UBLOG(logINFO, "* uReal         ="<<uReal);
   UBLOG(logINFO, "* nueReal       ="<<nueReal);
   UBLOG(logINFO, "* nue           ="<<nueLB);
   UBLOG(logINFO, "* velocity      ="<<uLB);
   UBLOG(logINFO, "* LX1 (world/LB)="<<kanallaengeSI<<"/"<<kanallaengeSI/coarseNodeDx);
   UBLOG(logINFO, "* LX2 (world/LB)="<<kanalbreiteSI<<"/"<<kanalbreiteSI/coarseNodeDx);
   UBLOG(logINFO, "* LX3 (world/LB)="<<kanalhoeheSI<<"/"<<kanalhoeheSI/coarseNodeDx);
   UBLOG(logINFO, "* dxInflow-Cube ="<<velBCCuboid->getX1Maximum()-mesh->getX1Minimum());
   UBLOG(logINFO, "* cdx           ="<<coarseNodeDx);
   UBLOG(logINFO, "* fdx           ="<<fineNodeDx);
  // UBLOG(logINFO, "* H_world       ="<<H);
  // UBLOG(logINFO, "* H_LB          ="<<H/coarseNodeDx);
   //UBLOG(logINFO, "* H_log_world   ="<<delta);
   //UBLOG(logINFO, "* H_log_LB      ="<<delta/baseDX);
   //UBLOG(logINFO, "* alpha         ="<<alpha);
   UBLOG(logINFO, "* inflowProfile ="<<inflowProfile.GetExpr());
   UBLOG(logINFO, "* dx_base       ="<<coarseNodeDx<<" == "<<coarseNodeDx);
   UBLOG(logINFO, "* dx_refine     ="<<fineNodeDx<<" == "<<fineNodeDx );
   UBLOG(logINFO, "* collModel     ="<<params.collModel);
   UBLOG(logINFO, "* raiseVelSteps ="<<raiseVelSteps);
   UBLOG(logINFO, "* startVis      ="<<startViscosity);
   UBLOG(logINFO, "* raiseVisSteps ="<<decreaseViscositySteps);
   UBLOG(logINFO, "* nx1/2/3       ="<<params.nx[0]<<"/"<<params.nx[1]<<"/"<<params.nx[2]);
   UBLOG(logINFO, "* blocknx1/2/3  ="<<params.blocknx[0]<<"/"<<params.blocknx[1]<<"/"<<params.blocknx[2]);
   UBLOG(logINFO, "* x3Periodic    ="<<params.periodic[2]);
   UBLOG(logINFO, "* useDirectConnectors           "<< params.connsTransAttr.useDirectConnectors()        ); 
   UBLOG(logINFO, "* useSTLVectorForSameLevelCons  "<< params.connsTransAttr.useStlVecForSameLevelCons()  ); 
   UBLOG(logINFO, "* useSTLVectorForScaleCons      "<< params.connsTransAttr.useStlVecForScaleCons()      ); 
   UBLOG(logINFO, "* useConsForNotActiveBlocks     "<< params.connsTransAttr.useConsForNotActiveBlocks() ); 
   UBLOG(logINFO, "* LODI           ="<< (useLODI ? "ON" : "OFF") ); 
   UBLOG(logINFO, "*****************************************");
   UBLOGML(logINFO, "UnitConverter:"<<unitConverter.toString());
   UBLOG(logINFO, "*****************************************");

   //////////////////////////////////////////////////////////////////////////
   //geo holen und setzen!!!
   //////////////////////////////////////////////////////////////////////////
   topoService.getAndAddAndInitInteractors();

   //////////////////////////////////////////////////////////////////////////
   UBLOG(logINFO, "//////////////////////////////////////////////////////////////////");
   int nofBlocks = topoService.getNumberOfBlocks(true);
   UBLOG(logINFO, "//active blocks after interactors: "<<nofBlocks);
   int nofAllBlocks = topoService.getNumberOfBlocks(false);
   UBLOG(logINFO, "//total blocks after interactors: "<<nofAllBlocks);
   UBLOG(logINFO, " -> ~"<<nofBlocks*(params.blocknx[0]+1)*(params.blocknx[1]+1)*(params.blocknx[2]+1)<<" nodes");
   UBLOG(logINFO, "//////////////////////////////////////////////////////////////////");

   //partitionierung
   UBLOG2(logINFO,cout, "levelweise METIS SEGMENTIERUNG!!!!")
      boost::shared_ptr<AMR3DGridAdaptationCriterion> partioningAdapter(new AMR3DGridLevelPartitionMetisAdapter( (int)calcServices.size()
      , D3Q19MetisAdapterTools::getMetisDirsAndWeights(  params.blocknx[0]
   , params.blocknx[1]
   , params.blocknx[2] )
      , params.connsTransAttr.useConsForNotActiveBlocks()
      , D3Q19MetisAdapterTools::getD3Q19GetBlockWeightFunctor(false) ) );   ///////hier false auf keine gewichtung - default:doppelte gewichtung f�r fine
   //  boost::shared_ptr<AMR3DGridAdaptationCriterion> partioningAdapter(new AMR3DGridPartitionOneDirectionAdapter((int)calcServices.size()) );   
  // UBLOG2(logINFO,"params.connsTransAttr.useConsForNotActiveBlocks():" ); 
   //UBLOG2(logINFO,params.connsTransAttr.useConsForNotActiveBlocks() );         
   topoService.adaptGridByGridCriterion(partioningAdapter);
   topoService.writeBlocksToAVS(outpath+"/blocksSegments",false);
   UBLOG2(logINFO,cout, "BlockSegmentsGeschriebe")
      //clientgrids erzeugen
      topoService.createClientGridsAndSendBlocksToClients("client",params.connsTransAttr,params.threadedClientCall);
   UBLOG2(logINFO,cout, "createClientGrids usw")



      boost::shared_ptr<D3Q19ClientGridWriteInteractorNodeFiles> writeInteractorTransNodesAdapter(new D3Q19ClientGridWriteInteractorNodeFiles("shared",D3Q19ClientGridWriteInteractorNodeFiles::ValueProjOnGeoVertex)); 
   writeInteractorTransNodesAdapter->setScheduler(UbSchedule(10000));
   writeInteractorTransNodesAdapter->addInteractorID( triBridgeInteractor ->getName() );

      //physik-daten zuweisen
      D3Q19GridPhysicsAdapter* physicsAdapter = new D3Q19GridPhysicsAdapter(params.collModel,viscosity,0.0,0.0,0.0);
   physicsAdapter->setSmagorinskyConstant(smagorinskiConstant);
   physicsAdapter->setUnitConverter( unitConverter );
   boost::shared_ptr<AMR3DGridAdaptationCriterion>  physicsAdapterPtr(physicsAdapter);

   //UbPointerWrapper<AMR3DGridAdaptationCriterion>   decreaseViscosityAdapter( new D3Q19GridPhysicsAdapter(decreaseViscositySteps, startViscosity, viscosity, decreaseViscosityStepForHalVis) );
   boost::shared_ptr<AMR3DGridAdaptationCriterion>  decreaseViscosityAdapter( new D3Q19GridPhysicsAdapter(decreaseViscositySteps, startViscosity, viscosity, decreaseViscosityStepForHalVis) );
   //boost::shared_ptr<AMR3DBlockAdaptationCriterion> initadapter(new D3Q19InitDistributionsAdapter(params.connsTransAttr.useConsForNotActiveBlocks(), params.collModel, params.rhoInit,(params.vx1Init*0.96),params.vx2Init,params.vx3Init, 0, AMR3DSystem::MAXLEVEL));

   boost::shared_ptr<AMR3DGridAdaptationCriterion> initadapter(new D3Q19InitDistributionsGridAdapter(params.rhoInit,params.vx1Init,params.vx2Init,params.vx3Init));
   if(initWithLogProfile) 
   {
    
      boost::dynamic_pointer_cast<D3Q19InitDistributionsGridAdapter>(initadapter)->setVx1( inflowProfile );
   }


   boost::shared_ptr<D3Q19ClientGridPostProcessFileAdapter> writeDumpsAdapter(new D3Q19ClientGridPostProcessFileAdapter("shared",true,false));
   writeDumpsAdapter->setScheduler(params.distributedDumpScheduler);
   writeDumpsAdapter->setUseFileCounterInsteadTimestepForGlobalPVD(true);


   UBLOG(logINFO, "put physicsAdapter to clients");
   calculationManager.adaptGridByGridCriterionAtClients(physicsAdapterPtr,params.threadedClientCall);

   boost::shared_ptr<AMR3DGridAdaptationCriterion>  hackAdapter(new D3Q19ChangeSlipToNoSlipGridAdapter());
   UBLOG2(logINFO, std::cout, "add hackAdapter to clients");
   calculationManager.addTimeDependentGridAdapterAtClients(hackAdapter,params.threadedClientCall);
   UBLOG2(logINFO, std::cout, "## adapter stuff - start"); 

   UBLOG(logINFO, "getAndAddInteractorsAtClients at clients");
   calculationManager.getAndAddInteractorsAtClients(params.threadedClientCall);

   UBLOG(logINFO, "put initadapter to clients");
   calculationManager.adaptGridByGridCriterionAtClients(initadapter,params.threadedClientCall);
   UBLOG(logINFO, "put setConnectorAdapter to clients");
   boost::shared_ptr<AMR3DGridAdaptationCriterion>  setConnectorAdapter(new D3Q19SetConnectorsGridAdapter( ) );
   calculationManager.adaptGridByGridCriterionAtClients(setConnectorAdapter,params.threadedClientCall);

   if(decreaseViscositySteps) calculationManager.addTimeDependentGridAdapterAtClients(decreaseViscosityAdapter,params.threadedClientCall);

   UBLOG(logINFO,"put writeAdapter to calc clients")
      calculationManager.addClientGridAdapterAtClients(writeDumpsAdapter,params.threadedClientCall);
   UBLOG(logINFO, "put writeInteractorTransNodesAdapter to clients" )
      calculationManager.addClientGridAdapterAtClients(writeInteractorTransNodesAdapter, params.threadedClientCall); 

   //remote connetoren
   UBLOG(logINFO, "setRemoteConnectorsOnCalcServices at clients");
   topoService.setRemoteConnectorsOnCalcServices(D3Q19System::getAMR3DDirsForD3Q19Dirs(),params.connsTransAttr,params.threadedClientCall);

    UbFileOutputASCII out(UbStaticPathMap::getPath(UbStaticPathMap::GLOBAL)+"/params.txt");
   if(out.isOpen())
   {
      UBLOG(logINFO, "save params to "<<out.getFileName());
      params.write(&out);
      out.writeLine();
      out.writeString("useLodi                  "); out.writeBool(useLODI);             out.writeLine();
      out.writeString("initWithLogProfile       "); out.writeBool(initWithLogProfile);  out.writeLine();
      UBLOG(logINFO, " done" )
   }


   //##########################################################################
   //## spongelayer
   //##########################################################################
   UBLOG2(logINFO, std::cout, "##################################################################");
   UBLOG2(logINFO, std::cout, "## spongelayer - start");

   GbCuboid3D* spongeCubeLeft = new GbCuboid3D( velBCCuboid->getX1Minimum() 
      , velBCCuboid->getX2Minimum() 
      , velBCCuboid->getX3Minimum() 
      , velBCCuboid->getX1Maximum()+(velBCCuboid->getX1Maximum()-velBCCuboid->getX1Minimum() )*0.1-1.0*coarseNodeDx 
      , velBCCuboid->getX2Maximum() 
      , velBCCuboid->getX3Maximum() );

   GbSystem3D::writeGeoObject( spongeCubeLeft, UbStaticPathMap::getPath(UbStaticPathMap::GLOBAL)+"/spongeIn", WbWriterVtkXmlBinary::getInstance() );
   boost::shared_ptr<AMR3DGridAdaptationCriterion>  spongeAdapterLeft( new SpD3Q19SpongeLayerAdapter(spongeCubeLeft, 1./3., nueLB,  SpD3Q19SpongeLayerAdapter::ALTERNATIONX1) );
   calculationManager.adaptGridByGridCriterionAtClients(spongeAdapterLeft ,params.threadedClientCall);



   UBLOG2(logINFO, std::cout, "## spongelayerOutflow - start");
                                                double H=kanallaengeSI/10.0;
   GbCuboid3D* spongeCubeRight = new GbCuboid3D( originX1+geoLength[0]+fineNodeDx-H 
      , originX2-geoOverlap             , originX3-geoOverlap
      , originX1+geoLength[0]+geoOverlap, originX2+geoLength[1]+geoOverlap, originX3+geoLength[2]+geoOverlap   );   

   GbSystem3D::writeGeoObject( spongeCubeRight, UbStaticPathMap::getPath(UbStaticPathMap::GLOBAL)+"/spongeOut", WbWriterVtkXmlBinary::getInstance() );
   boost::shared_ptr<AMR3DGridAdaptationCriterion>  spongeAdapterRight( new SpD3Q19SpongeLayerAdapter(spongeCubeRight,  nueLB,1./3.,  SpD3Q19SpongeLayerAdapter::ALTERNATIONX1) );
   calculationManager.adaptGridByGridCriterionAtClients(spongeAdapterRight ,params.threadedClientCall);
   UBLOG2(logINFO, std::cout, "## spongelayer - end");
   UBLOG2(logINFO, std::cout, "##################################################################");



   //GbCuboid3D* densCuboid = NULL;
   //##########################################################################

   calculationManager.calculate(params.calcSteps, UbStaticPathMap::GLOBAL, params.schedulers);

   UBLOG(logINFO, "warte nun auf ende!!");

}

