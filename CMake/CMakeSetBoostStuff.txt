# - Try to find Boost include dirs and libraries
# Usage of this module as follows:
#
#     SET(BOOST_USE_STATIC_LIBS ON)
#     SET(BOOST_USE_MULTITHREAD OFF)
#     FIND_PACKAGE( Boost 1.34.1 COMPONENTS date_time filesystem iostreams ... )
#
# The BOOST_ADDITIONAL_VERSIONS variable can be used to specify a list of
# boost version numbers that should be taken into account when searching
# for the libraries. Unfortunately boost puts the version number into the
# actual filename for the libraries, so this might be needed in the future
# when new Boost versions are released.
#
# Currently this module searches for the following version numbers:
# 1.33, 1.33.0, 1.33.1, 1.34, 1.34.0, 1.34.1, 1.35, 1.35.0, 1.35.1, 1.36.0,
# 1.36.1, 1.37.0,1.38.0
#
# The components list needs to be the actual names of boost libraries, that is
# the part of the actual library files that differ on different libraries. So
# its "date_time" for "libBOOST_date_time...". Anything else will result in
# errors
#
# You can provide a minimum version number that should be used. If you provide this 
# version number and specify the REQUIRED attribute, this module will fail if it
# can't find the specified or a later version. If you specify a version number this is
# automatically put into the considered list of version numbers and thus doesn't need
# to be specified in the BOOST_ADDITIONAL_VERSIONS variable
#
# Variables used by this module, they can change the default behaviour and need to be set
# before calling find_package:
#  BOOST_USE_MULTITHREAD         Can be set to OFF to use the non-multithreaded
#                                boost libraries. Defaults to ON.
#  BOOST_USE_STATIC_LIBS         Can be set to ON to force the use of the static
#                                boost libraries. Defaults to OFF.
#  BOOST_INCLUDEDIR              Set this to the include directory of Boost, if the
#                                module has problems finding the proper Boost installation
#  BOOST_LIBRARYDIR              Set this to the lib directory of Boost, if the
#                                module has problems finding the proper Boost installation
#  BOOST_AUTO_LIB_EXT_DETECTION  compiler suffix for boost libs will be detected automatically
#                                (e.g. "-gcc33", "-il")
#
#  BOOST_LIB_COMPILER_EXTENSION  compiler suffix for boost libs (e.g. "-gcc33", "-il") 
#                                (ONLY IF BOOST_AUTO_LIB_EXT_DETECTION is unset)
#
#
# Variables defined by this module:
#
#  BOOST_FOUND                          System has Boost, this means the include dir was found,
#                                       as well as all the libraries specified in the COMPONENTS list
#  BOOST_LIBRARIES                      Link these to use the Boost libraries that you specified, not cached
#  BOOST_FOUND_VERSION                  The version number of the boost libraries that have been found,
#                                       same as in version.hpp from Boost
#  BOOST_FOUND_LIB_VERSION              The version number in filename form as its appended to the library filenames
#  BOOST_MAJOR_VERSION                  major version number of boost
#  BOOST_MINOR_VERSION                  minor version number of boost
#  BOOST_SUBMINOR_VERSION               subminor version number of boost
#  BOOST_LIB_DIAGNOSTIC_DEFINITIONS     Only set on windows. Can be used with add_definitions 
#                                       to print diagnostic information about the automatic 
#                                       linking done on windows.

# For each component you list the following variables are set.
# ATTENTION: The component names need to be in lower case, just as the boost
# library names however the cmake variables use upper case for the component
# part. So you'd get BOOST_SERIALIZATION_FOUND for example.
#
#  BOOST_${COMPONENT}_FOUND             True IF the Boost library "component" was found.
#  BOOST_${COMPONENT}_LIBRARY           The absolute path of the Boost library "component".
#  BOOST_${COMPONENT}_LIBRARY_DEBUG     The absolute path of the debug version of the
#                                       Boost library "component".
#  BOOST_${COMPONENT}_LIBRARY_RELEASE   The absolute path of the release version of the
#                                       Boost library "component"
#

# this module required CMake 2.5 for the BOOST_FIND_VERSION stuff
#CMAKE_MINIMUM_REQUIRED(VERSION "2.6" FATAL_ERROR)
SET(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS 1)


###########################################################################
# das folgende macro sucht alle Header aus toBeIncludedFiles files nach
# SF::register< XXX >("XXX") durch und stellt anhand dieser informationen 
# eine Include Datei zusammen, die man benoetigt um boost serialization mit 
# abgeleiteten Klassen zu verwenden
###########################################################################
MACRO( CREATE_BOOST_EXPORT_FILE toBeIncludedFiles )

  ##################################################
  # clear cars
  ##################################################
  SET(includeFiles   "")
  SET(derivedClasses "")
  
  ##################################################
  #find all classes and files for boost macro
  ##################################################

  FOREACH(infile ${toBeIncludedFiles}) #ARGN is infiles-list!!!
    GET_FILENAME_COMPONENT(fileext ${infile} EXT)

    IF("${fileext}" STREQUAL ".h")
      FILE(READ "${infile}" file) #kopier kompletten dateiinhalt in variable "file"
      SET(className "")
      SET(isIncludeFile FALSE)
      
      while(NOT className STREQUAL file)
         STRING(REGEX REPLACE ".*SF\\:\\:registerType<[ ]*(.*)[ ]*>[ ]*\\([ ]*\".*" "\\1" className "${file}")
 
        IF(NOT className STREQUAL file) #wenn nichts zu ersetzen ist.. -> steht in className wieder komplettes file
             #check ob Klasse abstrakt //MUSS MAN NICHT MACHEN
             #STRING(REGEX MATCH "SF_NO_CTOR\\([ ]*${className}[ ]*\\)" abstractCheck "${file}")
             STRING(REGEX REPLACE "(.*)SF\\:\\:registerType<[ ]*${className}[ ]*>\\(.*" "\\1" file "${file}")
             
             #IF(NOT abstractCheck)
               SET(derivedClasses ${derivedClasses} ${className} )
               SET(isIncludeFile TRUE)
             #ENDIF()
         ENDIF()

      ENDWHILE()

      IF(isIncludeFile)
        SET(includeFiles ${includeFiles} ${infile} )
      ENDIF()
    ENDIF()  
  ENDFOREACH(infile ${infiles})

  ##################################################
  # update main if necessary
  # (hier wird u.a. das BoostExportFile.h erzeugt)
  ##################################################
  FOREACH(infile ${ARGN}) 
    STRING(REGEX MATCH ".*main.cpp" myMain ${infile} )
    IF(myMain)
      GET_FILENAME_COMPONENT(myMainPath ${myMain} PATH)
      SET(boostExportFile "${myMainPath}/BoostExportFile.h")
    
      #shorten boost-exportFileName
      STRING(REGEX REPLACE "\\\\" "/" file "${boostExportFile}")       
      STRING(REGEX REPLACE "${SOURCE_ROOT}/(.*)" "\\1" file "${boostExportFile}")

      #split main
      FILE(READ "${myMain}" myMainContent)

      SET(newLines "//inserted by CMake\n#ifdef RCF_USE_BOOST_SERIALIZATION\n")
      SET(newLines "${newLines}  #include \"./BoostExportFile.h\"\n")
      SET(newLines "${newLines}#endif //RCF_USE_BOOST_SERIALIZATION\n//\n// insert nothing here (will be deleted by CMake)\n//\n")
      
      STRING(REGEX MATCH "#include \"./BoostExportFile.h\"" check "${myMainContent}")       

      IF(NOT check)
        #ALLES VOR //inserted by CMake in firstPartMain speichern buw alles vor main
		  STRING(REGEX MATCH "//inserted by CMake" check "${myMainContent}")       
        IF(check) 
			 SET( firstPartMain ${myMainContent} )
          WHILE(check)
				STRING(REGEX REPLACE "(.*)//inserted by CMake(.*)" "\\1" firstPartMain  "${firstPartMain}")
				STRING(REGEX MATCH "//inserted by CMake" check "${firstPartMain}")       
          ENDWHILE()
        ELSE()
          STRING(REGEX REPLACE "(.*)int main\\((.*)" "\\1" firstPartMain  "${myMainContent}")       
        ENDIF()
        STRING(REGEX REPLACE "(.*)int main\\((.*)" "\\2" secondPartMain "${myMainContent}")       
        #write new extended main
        FILE(WRITE  ${myMain} "${firstPartMain}")
        FILE(APPEND ${myMain} "${newLines}")
        FILE(APPEND ${myMain} "int main(")
        FILE(APPEND ${myMain} "${secondPartMain}")
      ENDIF()
    ENDIF()
  ENDFOREACH()

  ##################################################
  # generate include file
  ##################################################
  IF(boostExportFile)
      SET(boostExportFile_tmp ${boostExportFile}_tmp)
      FILE(WRITE  ${boostExportFile_tmp} "//File is automatic generated by CMake::SET_BOOST_STUFF \n")
      FILE(APPEND ${boostExportFile_tmp} "//do not change anything! SirAnn \n")
      FILE(APPEND ${boostExportFile_tmp} "#ifndef CAB_BOOST_EXPORT\n")
      FILE(APPEND ${boostExportFile_tmp} "#define CAB_BOOST_EXPORT\n\n")
      FILE(APPEND ${boostExportFile_tmp} "  #ifdef RCF_USE_BOOST_SERIALIZATION\n\n")
    
      FOREACH(file ${includeFiles}) 
        STRING(REGEX REPLACE "\\\\" "/" file "${file}")  
        STRING(REGEX REPLACE "${SOURCE_ROOT}/(.*)" "\\1" file "${file}")
        FILE(APPEND ${boostExportFile_tmp} "    #include<${file}>\n")
      ENDFOREACH()
    
    	FILE(APPEND ${boostExportFile_tmp} "\n")
    
    	FILE(APPEND ${boostExportFile_tmp} "    #include <boost/serialization/export.hpp>\n")
    	FILE(APPEND ${boostExportFile_tmp} "    #include <boost/serialization/void_cast.hpp>\n\n")

    	FOREACH(className ${derivedClasses}) 
    	  FILE(APPEND ${boostExportFile_tmp} "    BOOST_CLASS_EXPORT_GUID( ${className}, \"${className}\" )\n")
    	ENDFOREACH()
    
    	FILE(APPEND ${boostExportFile_tmp} "\n  #endif //RCF_USE_BOOST_SERIALIZATION\n")
    	FILE(APPEND ${boostExportFile_tmp} "#endif //CAB_BOOST_EXPORT\n")

    	#compare
    	SET(schonDa FALSE)
    	FILE(READ ${boostExportFile_tmp} tmp)
          
    	IF(EXISTS ${boostExportFile})
    	  FILE(READ ${boostExportFile}       org)
    	  STRING(COMPARE EQUAL ${org} ${tmp} schonDa)
    	ENDIF()

    	IF(NOT schonDa)
      	FILE(WRITE  ${boostExportFile} ${tmp})
      	SOURCE_GROUP(generated_file FILES ${boostExportFile})
      	LIST(APPEND ${boostExportFile} )
    	ENDIF()
    
    	FILE(REMOVE ${boostExportFile_tmp})
      
  	ENDIF()

ENDMACRO( CREATE_BOOST_EXPORT_FILE toBeIncludedFiles )


############################################
#
# Check the existence of the libraries.
#
#########################################################################
# This macro was taken directly from the FindQt4.cmake file that is included
# with the CMake distribution. This is NOT my work. All work was done by the
# original authors of the FindQt4.cmake file. Only minor modifications were
# made to remove references to Qt and make this file more generally applicable
#########################################################################
MACRO(BOOST_ADJUST_LIB_VARS basename)
  IF (BOOST_${basename}_LIBRARY_DEBUG AND BOOST_${basename}_LIBRARY_RELEASE)
      # if the generator supports configuration types then set
      # optimized and debug libraries, or if the CMAKE_BUILD_TYPE has a value
      IF (CMAKE_CONFIGURATION_TYPES OR CMAKE_BUILD_TYPE)
        SET(BOOST_${basename}_LIBRARY optimized ${BOOST_${basename}_LIBRARY_RELEASE} debug ${BOOST_${basename}_LIBRARY_DEBUG})
      ELSE(CMAKE_CONFIGURATION_TYPES OR CMAKE_BUILD_TYPE)
        # if there are no configuration types and CMAKE_BUILD_TYPE has no value
        # then just use the release libraries
        SET(BOOST_${basename}_LIBRARY ${BOOST_${basename}_LIBRARY_RELEASE} )
      ENDIF(CMAKE_CONFIGURATION_TYPES OR CMAKE_BUILD_TYPE)
      SET(BOOST_${basename}_LIBRARIES optimized ${BOOST_${basename}_LIBRARY_RELEASE} debug ${BOOST_${basename}_LIBRARY_DEBUG})
    ENDIF (BOOST_${basename}_LIBRARY_DEBUG AND BOOST_${basename}_LIBRARY_RELEASE)

    # if only the release version was found, set the debug variable also to the release version
    IF (BOOST_${basename}_LIBRARY_RELEASE AND NOT BOOST_${basename}_LIBRARY_DEBUG)
      SET(BOOST_${basename}_LIBRARY_DEBUG ${BOOST_${basename}_LIBRARY_RELEASE})
      SET(BOOST_${basename}_LIBRARY       ${BOOST_${basename}_LIBRARY_RELEASE})
      SET(BOOST_${basename}_LIBRARIES     ${BOOST_${basename}_LIBRARY_RELEASE})
    ENDIF (BOOST_${basename}_LIBRARY_RELEASE AND NOT BOOST_${basename}_LIBRARY_DEBUG)

    # if only the debug version was found, set the release variable also to the debug version
    IF (BOOST_${basename}_LIBRARY_DEBUG AND NOT BOOST_${basename}_LIBRARY_RELEASE)
      SET(BOOST_${basename}_LIBRARY_RELEASE ${BOOST_${basename}_LIBRARY_DEBUG})
      SET(BOOST_${basename}_LIBRARY         ${BOOST_${basename}_LIBRARY_DEBUG})
      SET(BOOST_${basename}_LIBRARIES       ${BOOST_${basename}_LIBRARY_DEBUG})
    ENDIF (BOOST_${basename}_LIBRARY_DEBUG AND NOT BOOST_${basename}_LIBRARY_RELEASE)
    
    IF (BOOST_${basename}_LIBRARY)
      SET(BOOST_${basename}_LIBRARY ${BOOST_${basename}_LIBRARY} CACHE FILEPATH "The Boost ${basename} library")
      GET_FILENAME_COMPONENT(BOOST_LIBRARYDIRS "${BOOST_${basename}_LIBRARY}" PATH)
      SET(BOOST_${basename}_FOUND ON CACHE INTERNAL "Was the boost boost ${basename} library found")
    ENDIF (BOOST_${basename}_LIBRARY)

  # Make variables changeble to the advanced user
  MARK_AS_ADVANCED(
      BOOST_${basename}_LIBRARY
      BOOST_${basename}_LIBRARY_RELEASE
      BOOST_${basename}_LIBRARY_DEBUG
  )
ENDMACRO(BOOST_ADJUST_LIB_VARS)


##################################################
##################################################
##################################################
##################################################
MACRO(SET_BOOST_STUFF )
  	SET(BOOST_FOUND FALSE)
  
  	CHECK_FOR_VARIABLE(BOOST_VERSION         "1.37.0 1.36.0 1.35.0, 1.34.1, 1.34.1")
  	IF(BOOST_VERSION)
		CHECK_FOR_VARIABLE(BOOST_INCLUDEDIR      "BOOST_INCLUDEDIR floders that includes /boost/version.hpp")
		CHECK_FOR_VARIABLE(BOOST_LIBRARYDIR      "BOOST_LIBRARYDIR floders that includes libs")
		CHECK_FOR_VARIABLE(BOOST_USE_MULTITHREAD "BOOST_USE_MULTITHREAD ON/OFF")
		CHECK_FOR_VARIABLE(BOOST_USE_STATIC_LIBS "BOOST_USE_STATIC_LIBS ON/OFF")                     
  	ELSE()
    	MESSAGE(FATAL_ERROR "BOOST_VERSION setzen, aber zackig!")
  	ENDIF()
                                                                                                  
  	IF(BOOST_INCLUDEDIR AND BOOST_LIBRARYDIR)
    	IF(EXISTS ${BOOST_INCLUDEDIR} AND EXISTS ${BOOST_LIBRARYDIR})
     	 	IF(WIN32)
	        # In windows, automatic linking is performed, so you do not have to specify the libraries.
	        # If you are linking to a dynamic runtime, then you can choose to link to either a static or a
	        # dynamic Boost library, the default is to do a static link.  You can alter this for a specific
	        # library "whatever" by defining BOOST_WHATEVER_DYN_LINK to force Boost library "whatever" to
	        # be linked dynamically.  Alternatively you can force all Boost libraries to dynamic link by
	        # defining BOOST_ALL_DYN_LINK.
	     
	        # This feature can be disabled for Boost library "whatever" by defining BOOST_WHATEVER_NO_LIB,
	        # or for all of Boost by defining BOOST_ALL_NO_LIB.
	     
	        # If you want to observe which libraries are being linked against then defining
	        # BOOST_LIB_DIAGNOSTIC will cause the auto-linking code to emit a #pragma message each time
	        # a library is selected for linking.
                SET(BOOST_LIB_DIAGNOSTIC_DEFINITIONS "-DBOOST_LIB_DIAGNOSTIC" CACHE STRING "Boost diagnostic define")
      	ENDIF()
      
	      # Extract BOOST_FOUND_VERSION and BOOST_FOUND_LIB_VERSION from version.hpp
	      # Read the whole file:
	      #
	      # Extract Boost_VERSION and BOOST_FOUND_LIB_VERSION from version.hpp
	      # Read the whole file:
	      #
	      SET(BOOST_FOUND_VERSION 0)
	      SET(BOOST_FOUND_LIB_VERSION "")
	      FILE(READ "${BOOST_INCLUDEDIR}/boost/version.hpp" _BOOST_FOUND_VERSION_HPP_CONTENTS)
	     
	      STRING(REGEX REPLACE ".*#define BOOST_VERSION ([0-9]+).*" "\\1"          BOOST_FOUND_VERSION     "${_BOOST_FOUND_VERSION_HPP_CONTENTS}")
	      STRING(REGEX REPLACE ".*#define BOOST_LIB_VERSION \"([0-9_]+)\".*" "\\1" BOOST_FOUND_LIB_VERSION "${_BOOST_FOUND_VERSION_HPP_CONTENTS}")
	     
	      IF(NOT "${BOOST_FOUND_VERSION}" STREQUAL "0")
	        MATH(EXPR Boost_MAJOR_VERSION "${BOOST_FOUND_VERSION} / 100000")
	        MATH(EXPR Boost_MINOR_VERSION "${BOOST_FOUND_VERSION} / 100 % 1000")
	        MATH(EXPR Boost_SUBMINOR_VERSION "${BOOST_FOUND_VERSION} % 100")
	      ENDIF(NOT "${BOOST_FOUND_VERSION}" STREQUAL "0")
    
	      SET(BOOST_FOUND_VERSION     ${BOOST_FOUND_VERSION}     CACHE INTERNAL "The version number for boost libraries")
	      SET(BOOST_FOUND_LIB_VERSION ${BOOST_FOUND_LIB_VERSION} CACHE STRING "The library version string for boost libraries" FORCE)
	      SET(BOOST_FOUND_VERSION_NUM ${Boost_MAJOR_VERSION}.${Boost_MINOR_VERSION}.${Boost_SUBMINOR_VERSION} CACHE STRING "The version number for boost libraries" FORCE)
      
	      #Setting some more suffixes for the library
	      SET (BOOST_LIB_PREFIX "lib")
	      IF ( WIN32 AND NOT BOOST_USE_STATIC_LIBS )
	        SET (BOOST_LIB_PREFIX "")
	      ENDIF( )
      
			IF( BOOST_COMPILER_SUFFIX )
				SET(BOOST_COMPILER ${BOOST_COMPILER_SUFFIX})
         ELSE()
	        	SET (BOOST_COMPILER "-gcc")
	        	IF(MSVC70)
	         	 SET (BOOST_COMPILER "-vc70")
	        	ELSEIF(MSVC71)
	          	SET(BOOST_COMPILER "-vc71")
	        	ELSEIF(MSVC80)
	          	SET(BOOST_COMPILER "-vc80")
	        	ELSEIF(MSVC90)
	          	SET(BOOST_COMPILER "-vc90")
	        	ELSEIF(MSVC100)
	          	SET(BOOST_COMPILER "-vc100")
	        	ELSEIF(MINGW)
	          	#EXEC_PROGRAM(${CMAKE_CXX_COMPILER} ARGS --version OUTPUT_VARIABLE BOOST_COMPILER_VERSION)
	          	#STRING(REGEX REPLACE ".* ([0-9])\\.([0-9])\\.[0-9] .*" "\\1\\2"
	           	#BOOST_COMPILER_VERSION ${BOOST_COMPILER_VERSION})
	          	SET (BOOST_COMPILER "-mgw${BOOST_COMPILER_VERSION}")
	        	ELSEIF(CYGWIN)
	         	SET (BOOST_COMPILER "-gcc")
	        	ELSEIF(UNIX)
	          IF (APPLE)
	              SET (BOOST_COMPILER "")
	          ELSE (APPLE)
	            IF (NOT CMAKE_COMPILER_IS_GNUCC)
	              # This is for the intel compiler
	              SET (BOOST_COMPILER "-il")
	            ELSE (NOT CMAKE_COMPILER_IS_GNUCC)
	              #find out the version of gcc being used.
	              EXEC_PROGRAM(${CMAKE_CXX_COMPILER}
	                            ARGS --version
	                            OUTPUT_VARIABLE BOOST_COMPILER_VERSION
	              	            )
	               STRING(REGEX REPLACE ".* ([0-9])\\.([0-9])\\.[0-9] .*" "\\1\\2"
	                      BOOST_COMPILER_VERSION ${BOOST_COMPILER_VERSION})
	               SET (BOOST_COMPILER "-gcc${BOOST_COMPILER_VERSION}")
	            	ENDIF (NOT CMAKE_COMPILER_IS_GNUCC)
	          	ENDIF (APPLE)
	        	ENDIF()
	      ENDIF()

	      IF( BOOST_USE_MULTITHREAD )
	        SET (BOOST_MULTITHREADED "-mt")
	      ELSE()
	        SET (BOOST_MULTITHREADED "")
	      ENDIF( )
    
	      SET( BOOST_STATIC_TAG "")
	      IF (WIN32)
	        IF(MSVC)
	          SET (BOOST_ABI_TAG "g")
	        ENDIF(MSVC)
	        IF( BOOST_USE_STATIC_LIBS )
	          SET( BOOST_STATIC_TAG "-s")
	        ENDIF( BOOST_USE_STATIC_LIBS )
	      ENDIF(WIN32)
	      SET (BOOST_ABI_TAG "${BOOST_ABI_TAG}d")
	      
	      # ------------------------------------------------------------------------
	      #  Begin finding boost libraries
	      # ------------------------------------------------------------------------
	      FOREACH(COMPONENT ${ARGN})
	        STRING(TOUPPER ${COMPONENT} UPPERCOMPONENT)
	        SET( BOOST_${UPPERCOMPONENT}_LIBRARY "BOOST_${UPPERCOMPONENT}_LIBRARY-NOTFOUND" )
	        SET( BOOST_${UPPERCOMPONENT}_LIBRARY_RELEASE "BOOST_${UPPERCOMPONENT}_LIBRARY_RELEASE-NOTFOUND" )
	        SET( BOOST_${UPPERCOMPONENT}_LIBRARY_DEBUG "BOOST_${UPPERCOMPONENT}_LIBRARY_DEBUG-NOTFOUND")
	      
	        # Support preference of static libs by adjusting CMAKE_FIND_LIBRARY_SUFFIXES
	        SET( BOOST_ORIG_CMAKE_FIND_LIBRARY_SUFFIXES ${CMAKE_FIND_LIBRARY_SUFFIXES})
	        IF( BOOST_USE_STATIC_LIBS AND WIN32)
	            SET(CMAKE_FIND_LIBRARY_SUFFIXES .lib .a ${CMAKE_FIND_LIBRARY_SUFFIXES})
	        ENDIF( )
	    
	        IF( BOOST_USE_STATIC_LIBS AND NOT WIN32)
	           SET(libExtension ".a") #irgendwie funzt CMAKE_FIND_LIBRARY_SUFFIXES unter unix nicht
	        ENDIF( )
	        IF( NOT BOOST_USE_STATIC_LIBS AND NOT WIN32)
	           IF(APPLE)
		           SET(libExtension ".dylib")
	           ELSE(APPLE)
		           SET(libExtension ".so") #irgendwie funzt CMAKE_FIND_LIBRARY_SUFFIXES unter unix nicht
		        ENDIF(APPLE)
	        ENDIF( )
	    
	       #MESSAGE(STATUS ${BOOST_LIB_PREFIX}boost_${COMPONENT}${BOOST_COMPILER}${BOOST_MULTITHREADED}-${BOOST_FOUND_LIB_VERSION}${libExtension})
	       
	        FIND_LIBRARY(BOOST_${UPPERCOMPONENT}_LIBRARY_RELEASE
	                     NAMES  ${BOOST_LIB_PREFIX}boost_${COMPONENT}${BOOST_COMPILER}${BOOST_MULTITHREADED}-${BOOST_FOUND_LIB_VERSION}${libExtension}
	                            ${BOOST_LIB_PREFIX}boost_${COMPONENT}${BOOST_COMPILER}${BOOST_MULTITHREADED}${BOOST_STATIC_TAG}-${BOOST_FOUND_LIB_VERSION}${libExtension}
	                            ${BOOST_LIB_PREFIX}boost_${COMPONENT}${BOOST_MULTITHREADED}${libExtension}
	                            ${BOOST_LIB_PREFIX}boost_${COMPONENT}${BOOST_MULTITHREADED}${BOOST_STATIC_TAG}${libExtension}
	                            ${BOOST_LIB_PREFIX}boost_${COMPONENT}${libExtension}
	                     PATHS  ${BOOST_LIBRARYDIR}
	                     NO_DEFAULT_PATH
	                   )
	        FIND_LIBRARY(BOOST_${UPPERCOMPONENT}_LIBRARY_DEBUG
	                     NAMES  ${BOOST_LIB_PREFIX}boost_${COMPONENT}${BOOST_COMPILER}${BOOST_MULTITHREADED}-${BOOST_ABI_TAG}-${BOOST_FOUND_LIB_VERSION}${libExtension}
	                            ${BOOST_LIB_PREFIX}boost_${COMPONENT}${BOOST_COMPILER}${BOOST_MULTITHREADED}${BOOST_STATIC_TAG}${BOOST_ABI_TAG}-${BOOST_FOUND_LIB_VERSION${libExtension}}
	                            ${BOOST_LIB_PREFIX}boost_${COMPONENT}${BOOST_MULTITHREADED}-${BOOST_ABI_TAG}${libExtension}
	                            ${BOOST_LIB_PREFIX}boost_${COMPONENT}${BOOST_MULTITHREADED}${BOOST_STATIC_TAG}${BOOST_ABI_TAG}${libExtension}
	                            ${BOOST_LIB_PREFIX}boost_${COMPONENT}-${BOOST_ABI_TAG}${libExtension}
	                     PATHS  ${BOOST_LIBRARYDIR}
	                     NO_DEFAULT_PATH
	                    )
	        
	        BOOST_ADJUST_LIB_VARS(${UPPERCOMPONENT})
	      
	        SET(BOOST_LIBRARIES ${BOOST_LIBRARIES} ${BOOST_${UPPERCOMPONENT}_LIBRARY})
	      
	        SET(CMAKE_FIND_LIBRARY_SUFFIXES ${BOOST_ORIG_CMAKE_FIND_LIBRARY_SUFFIXES})
	      ENDFOREACH(COMPONENT ${ARGN})
	      # ------------------------------------------------------------------------
	      #  End finding boost libraries
	      # ------------------------------------------------------------------------
      
	      ## BOOST_FOUND
	      IF(BOOST_FOUND_VERSION)
	        SET( BOOST_FOUND TRUE )
	        LIST(APPEND CAB_ADDTIONAL_COMPILER_FLAGS -DCAB_BOOST=${BOOST_FOUND_VERSION})
	      ENDIF()
	      
	      #Under Windows, automatic linking is performed, so no need to specify the libraries.
	      IF(WIN32)
	        	IF(NOT MINGW)
	          SET(BOOST_LIBRARIES "")
	        	ENDIF (NOT MINGW)
	      ENDIF(WIN32)

	      INCLUDE_DIRECTORIES( ${BOOST_INCLUDEDIR}  )
	      LINK_DIRECTORIES( ${BOOST_LIBRARYDIR} )
	      LINK_LIBRARIES ( ${BOOST_LIBRARIES} )
    	ELSE()
	      IF( NOT EXISTS ${BOOST_INCLUDEDIR} )
     	   	MESSAGE("BOOST_INCLUDEDIR = \\""${BOOST_INCLUDEDIR}"\\" does not exist")
	      ENDIF()

	      IF( NOT EXISTS ${BOOST_LIBRARYDIR} )
     	      MESSAGE("BOOST_LIBRARYDIR = \\""${BOOST_LIBRARYDIR}"\\" does not exist")
	      ENDIF()
    	ENDIF()
 	ELSE() 
   	IF(NOT BOOST_INCLUDEDIR)
      	MESSAGE("variable BOOST_INCLUDEDIR not set")
    	ENDIF()
    	IF(NOT BOOST_LIBRARYDIR)
       	MESSAGE("variable BOOST_LIBRARYDIR not set")
    	ENDIF()
    
 	ENDIF()
 
 IF(NEED_BOOST_EXPORT_FILE)
   CREATE_BOOST_EXPORT_FILE( ${ALL_SOURCES})
 ENDIF()
ENDMACRO(SET_BOOST_STUFF )
   
